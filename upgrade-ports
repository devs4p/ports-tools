#!/bin/sh

readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly CONFIG="${XDG_CONFIG_HOME}/upgrade-ports"

PORTSDIR=${PORTSDIR:-/usr/ports}

answer_yes=0	# answer yes to all of the questions
skip_update=0	# don't update ports tree
wait_for_key=0	# wait for key press after update finish

ask_yesno() {
	[ ${answer_yes} -eq 0 ] || return 0
	while true; do
		printf "\n${1} (y/n)? [y] "
		
		read answer
		[ "${answer}" ] || answer="y"

		case ${answer} in
		[Nn])
			return 1 ;;
		[Yy])
			return 0
		esac
	done
}

check_for_missing_deps() {
	local m_deps
	deps=$(make -C ${PORTSDIR}/${1} -VFETCH_DEPENDS -VEXTRACT_DEPENDS \
		-VPATCH_DEPENDS -VBUILD_DEPENDS -VLIB_DEPENDS -VRUN_DEPENDS |
		tr ' ' '\n' | cut -d':' -f2 | sort -u)
	for dep in ${deps}; do
		if ! pkg_exists ${dep}; then
			m_deps="${m_deps} ${dep}"
			ret=$(check_for_missing_deps ${dep})
			[ "${ret}" ] && m_deps="${m_deps} ${ret}"
		fi
	done
	[ "${m_deps}" ] && echo ${m_deps}
}

command_is_valid() {
	local old_IFS=${IFS}

	IFS=" "
	if [ "${*%% *}" = "pkg" ]; then
		cmd_pkg_validate ${*#pkg }
	else
		cmd_pm_validate ${*#portmaster }
	fi
	ret=${?}
	IFS=${old_IFS}
	return ${ret}
}

cmd_pkg_validate() {
	local check_exists=0 command

	for arg in ${*}; do
		if [ ! "${command}" ]; then
			command=${arg}
			[ "${command}" = "delete" ] && check_exists=1
			[ "${command}" = "info" ] && return 1
			continue
		fi
		case ${arg} in
			-o)
				check_exists=1
				continue ;;
			-*)
				echo "===> Pkg unhandled option: ${arg}"
				return 1
		esac
		if [ ${check_exists} -eq 1 ]; then
			if ! pkg_exists ${arg%:*}; then
				echo "===> ${arg%:*} is not installed, skipping 'pkg ${*}' command"
				return 1
			else
				check_exists=0
			fi
		fi
	done
	return 0
}

cmd_pm_validate() {
	local change_origin=0 check_exists=0

	for arg in ${*}; do
		case ${arg} in
		-a)
			echo "===> Skipping upgrade of all packages for now (portmaster ${*})"
			return 1 ;;
		-f|-w)
			continue ;;
		-o)
			change_origin=1
			continue ;;
		-r)
			check_exists=1
			continue ;;
		-*)
			echo "===> Portmaster unhandled option: ${arg}"
			return 1
		esac
		if [ ${change_origin} -eq 1 ]; then
			change_origin=0
			check_exists=1
			continue
		fi
		if [ ${check_exists} -eq 1 ]; then
			if ! pkg_exists ${arg}; then
				echo "===> ${arg} is not installed, skipping 'portmaster ${*}' command"
				return 1
			else
				check_exists=0
			fi
		fi
	done
	return 0
}

display_usage() {
	<< EOF >&2 cat
Usage: ${0##*/} [-h|-u|-w|-y]

    -h - show this help
    -u - don't update ports tree
    -w - wait for key press after finish
    -y - answer yes to all questions

EOF
	exit 1
}

get_entry_dates() {
	egrep "^[0-9]{8}:" ${PORTSDIR}/UPDATING | sed 's/://'
}

get_moved_ports() {
	awk -F '|' -v date="${1}" '
	!/^#/ && NR = 4 && $2 {
		gsub("-", "", $3);
		if ($3 > date)
			print $1 ":" $2;
	}' ${PORTSDIR}/MOVED
}

get_removed_ports() {
	awk -F '|' -v date="${1}" '
	!/^#/ && NR = 4 && !$2 {
		gsub("-", "", $3);
		if ($3 > date)
			print $1;
	}' ${PORTSDIR}/MOVED
}

pkg_exists() {
	[ "${1}" ] || return 1
	pkg-static info --exists ${1} >/dev/null 2>&1
}

ports_upgrade_sort() {
	echo ${*} | tr ' ' '\n' | awk -v portsdir="${PORTSDIR}" '
	function partition(a, s, e) {
		i = s-1; j = e+1;

		while(1) {
			do i++; while (ports_cmp(a[i], a[s]) < 0)
			do j--; while (ports_cmp(a[j], a[s]) > 0)

			if (i >= j)
				return j;

			tmp = a[i]; a[i] = a[j]; a[j] = tmp;
		}
	}
	function ports_cmp(a, b) {
		if (match(port_deps[b], a))
			return -1;
		if (match(port_deps[a], b))
			return 1;
		return port_ndeps[a] - port_ndeps[b];
	}
	function qsort(a, start, end) {
		if (start >= end)
			return;
		p = partition(a, start, end);
		qsort(a, start, p);
		qsort(a, p+1, end);
	}
	{
		ports[++n_ports] = $0;
		while ("make -C " portsdir "/" $0 " all-depends-list" | getline line) {
			sub(portsdir "/", " ", line);
			port_deps[$0] = port_deps[$0] line;
			port_ndeps[$0]++;
		}
	}
	END {
		qsort(ports, 1, n_ports);
		for(x=1; x<=n_ports; x++)
			print ports[x];
	}'
}

print_list() {
	[ "${2}" ] || return
	printf "\n${1}\n"
	for item in ${2}; do printf "\t${item}\n"; done | sort
}

rebuild_ports() {
	echo "===> Calculating ports upgrade order"
	for port in $(ports_upgrade_sort ${*}); do
		case ${build_skipped} in *${port}*) continue ;; esac
		[ -d ${PORTSDIR}/${port} ] || continue
		cd ${PORTSDIR}/${port}
		[ -d work ] && ${SUDO} make clean
		pkg_exists ${port} && make_cmd="reinstall" || make_cmd="install"
		${SUDO} make ${make_cmd} clean
		if [ ${?} -ne 0 ]; then
			build_failed="${build_failed} ${port}"
			consumers=$(pkg-static query %ro ${port})
			[ "${consumers}" ] || continue
			for con in ${consumers}; do
				case ${need_upgrade} in *${con}*)
					build_skipped="${build_skipped} ${con}" ;;
				esac
			done
		fi
	done
}

removal_reason() {
	awk -F '|' -v port="${1}" '
	!/^#/ && NR = 4 && $1 == port { print $4 }' ${PORTSDIR}/MOVED
}

updating_commands() {
	awk -F ':' -v entry="${1}" '
	function strip_command(str) {
		sub("^[ \t#]*", "", str);
		in_cmd = sub(/\\$/, "", str);
		return str;
	}
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		if (entry == $1)
			in_entry=1;
		else if (in_entry)
			exit;
	}
	in_entry && !in_cmd {
		if (match($0, /^[ \t#]*(pkg|portmaster) /)) {
			cmd = strip_command($0);
			if (!in_cmd) {
				print cmd;
				cmd="";
			}
		}
		next;
	}
	in_entry && in_cmd {
		line = strip_command($0);
		if (in_cmd)
			cmd=cmd line;
		else {
			print cmd line;
			cmd="";
		}
	}' ${PORTSDIR}/UPDATING
}

updating_entry() {
	awk -F ':' -v entry="${1}" '
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		if (entry == $1)
			in_entry=1;
		else if (in_entry)
			exit;
	}
	in_entry { print $0 }' ${PORTSDIR}/UPDATING
}

# $1 - exit status
# $2 - last read/executed UPDATING entry
# $3 - wait for final keypress?
upgrade_exit() {
	local keywait=${3}

	[ "${2}" ] && echo ${2} > ${CONFIG}
	[ "${keywait}" ] || keywait=${wait_for_key}
	[ "${tmpfile}" -a -f "${tmpfile}" ] && rm -rf "${tmpfile}"

	if [ ${keywait} -eq 1 ]; then
		printf "\n===> Press Enter key to finish.\n\n"
		read key
	fi
	exit ${1}
}

while getopts "huwy" option; do
	case ${option} in
	u)
		skip_update=1 ;;
	w)
		wait_for_key=1 ;;
	y)
		portmaster_args="--no-confirm"
		answer_yes=1 ;;
	*)
		display_usage
	esac
done

[ -d "${PORTSDIR}" ] ||
	PORTSDIR="$(make -V PORTSDIR /usr/share/mk/bsd.ports.mk 2>/dev/null)"
if [ ! -d "${PORTSDIR}" ]; then
	echo "===> Ports directory not found: ${PORTSDIR}, try setting PORTSDIR variable" >&2
	exit 1
fi

if [ $(id -u) -ne 0 ]; then
	if ! which sudo >/dev/null; then
		echo "===> sudo not found" >&2
		upgrade_exit 1
	fi
	SUDO="sudo"
fi
if ! which portmaster >/dev/null; then
	echo "===> portmaster not found" >&2
	upgrade_exit 1
fi

if [ -f "${CONFIG}" ]; then
	last_read="$(cat "${CONFIG}")"
else
	[ -d "${XDG_CONFIG_HOME}" ] || mkdir "${XDG_CONFIG_HOME}"
fi
[ "${last_read}" ] || last_read="$(get_entry_dates | head -n 1)"

if [ ${skip_update} -eq 0 ]; then
	if ! ${SUDO} portsnap fetch update; then
		echo "===> Ports tree update failed" >&2
		upgrade_exit 1
	fi
fi

for port in $(get_removed_ports ${last_read}); do
	if pkg_exists ${port}; then
		if ask_yesno "Remove obsolete ${port} ($(removal_reason ${port}))"
		then
			${SUDO} pkg-static delete --yes --force ${port}
		fi
	fi
done
for ports in $(get_moved_ports ${last_read}); do
	pkg_exists ${ports%%:*} &&
		${SUDO} pkg-static set --change-origin ${ports} --yes &&
		echo "===> Port ${ports%%:*} moved to ${ports##*:}"
done

last_upd="$(get_entry_dates | head -n 1)"

if [ ${last_read} -lt ${last_upd} ]; then
	tmpfile="$(mktemp -t ${0##*/})"
	if [ ! "${tmpfile}" ]; then
		echo "===> Failed to create temporary file" >&2
		upgrade_exit 1
	fi

	printf "===> New entries since last upgrade in ${PORTSDIR}/UPDATING file:\n\n"
	for entry in $(get_entry_dates | sort -u); do
		[ ${entry} -gt ${last_read} ] || continue
		
		updating_entry ${entry}
		updating_commands ${entry} > ${tmpfile}

		old_IFS=${IFS}
		IFS=$'\n'
		
		for cmd in $(cat ${tmpfile}); do
			command_is_valid ${cmd} || continue
			case ${cmd} in "portmaster "*)
				cmd="${cmd} ${portmaster_args}"
			esac

			if ask_yesno "Run '${cmd}'"; then
				IFS=${old_IFS}
				${SUDO} ${cmd}
				ret=${?}
				IFS=$'\n'
				
				if [ ${ret} -ne 0 ]; then
					echo "===> Upgrade command '${cmd}' failed" >&2
					upgrade_exit ${ret} ${entry_prev}
				fi
			fi
		done
		
		IFS=${old_IFS}
		entry_prev="${entry}"
	done
fi

echo "===> Checking for ports needing upgrade"
for port in $(env PORTSDIR=${PORTSDIR} pkg-static version -o -l '<' | cut -f1 -d' '); do
	[ "$(pkg-static info -kq ${port})" == "yes" ] && continue
	need_upgrade="${need_upgrade} ${port}"
done
if [ ! "${need_upgrade}" ]; then
	echo "===> No ports needing upgrade found"
	upgrade_exit 0 ${last_upd}
fi

need_install=$(for port in ${need_upgrade}; do
	check_for_missing_deps ${port}
done | tr ' ' '\n' | sort -u)

for port in ${need_upgrade} ${need_install}; do
	conflicts=$(make -C ${PORTSDIR}/${port} -VCONFLICTS -VCONFLICTS_BUILD \
		-VCONFLICTS_INSTALL)
	[ "${conflicts}" ] || continue
	for cnfl in ${conflicts}; do
		for origin in $(pkg-static query -g %o "${cnfl}"); do
			need_remove="${need_remove} ${origin} $(pkg-static query %ro ${origin})"
			[ "${port}" == "${origin}" ] &&
				conflicts_self="${conflicts_self} ${port}"
		done
	done
done

print_list "Following ports need to be REMOVED:" "${need_remove}"
print_list "Following ports need to be INSTALLED:" "${need_install} ${conflicts_self}"
print_list "Following ports will be UPGRADED:" "${need_upgrade}"
if ask_yesno "Proceed with upgrade"; then
	${SUDO} pkg-static delete --yes ${need_remove}
	rebuild_ports ${need_upgrade} ${conflicts_self}
else
	upgrade_exit 0 ${last_upd}
fi

for pkg in ${build_failed} ${build_skipped} $(pkg-static lock -lq); do
	pkg_ignore="${pkg_ignore} $(pkg-static query %n ${pkg})"
done
echo "===> Checking packages for missing libraries/dependencies"
pkgs_rebuild=$(${SUDO} pkg-static check -dan | awk -v pkg_ignore="${pkg_ignore}" '
BEGIN {
	if ((n = split(pkg_ignore, array, " ")) > 0)
		for (i=1; i<=n; i++)
			ignore[array[i]] = array[i];
}
function pkg_needs_rebuild(pkg) {
	for (pattern in ignore)
		if (match(pkg, pattern))
			return 0;
	if (pkg in rebuild)
		return 0;
	return 1;
}
/is missing a required shared library:/ {
	if (!pkg_needs_rebuild($1))
		next;
	rebuild[$1] = $1;
}
/has a missing dependency:/ {
	if (!pkg_needs_rebuild($6))
		next;
	"pkg-static rquery -e '\''%n = " $6  "'\'' %o" | getline origin
	if (origin)
		rebuild[$6] = origin;
}
END {
	for (i in rebuild)
		printf("%s ", rebuild[i]);
}')

if [ "${pkgs_rebuild}" ]; then
	for pkg in ${pkgs_rebuild}; do
		case pkg in
			*/*) inst="${inst} ${pkg}" ;;
			*)
				rinst="${rinst} ${pkg}"
				o_rinst="${o_rinst} $(pkg-static info -oq ${pkg})"
		esac
	done
	print_list "Ports need to be INSTALLED:" "${inst}"
	print_list "Packages need to be REINSTALLED:" "${rinst}"
	if ask_yesno "Continue with changes"; then
		rebuild_ports ${inst} ${o_rinst}
		upgrade_exit ${?} ${last_upd}
	fi
fi
if [ "${build_failed}" ]; then
	printf "\nNot all ports were upgraded successfully, check your system and try again.\n\n"
	print_list "Following ports failed to be UPGRADED:" "${build_failed}"
	print_list "Following ports upgrades were SKIPPED:" "${build_skipped}"
	upgrade_exit 1 ${last_upd}
fi
upgrade_exit 0 ${last_upd}

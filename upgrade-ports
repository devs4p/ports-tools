#!/bin/sh

readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly CONFIG="${XDG_CONFIG_HOME}/upgrade-ports"
readonly PAGER="${PAGER:-less}"

PORTSDIR=${PORTSDIR:-/usr/ports}

answer_yes=0
wait_for_key=0

ask_yesno() {
	while true; do
		echo -n "${1} (y/n)? [y] "
		
		read answer
		[ -n "${answer}" ] || answer="y"

		case ${answer} in
		[Nn])
			return 1 ;;
		[Yy])
			return 0
		esac
	done
}

command_is_relevant() {
	local change_origin=0 old_IFS=${IFS} upgrade_prg=""

	IFS=" "
	for arg in ${*}; do
		[ -n "${upgrade_prg}" ] || upgrade_prg="${arg}"
		case ${arg} in
		"-a")
			if [ "${upgrade_prg}" = "portmaster" ]; then
				printf "Skipping upgrade of all packages for now (${*})\n\n"
				IFS=${old_IFS}
				return 1
			fi
			;;
		"-o")
			change_origin=1
			continue
		esac

		if [ ${change_origin} -ne 0 ]; then
			if [ "${upgrade_prg}" = "portmaster" -a \
				${change_origin} -eq 1 ]
			then
				change_origin=2
				continue
			fi

			local ret=$(pkg info -e ${arg%:*}; echo ${?})
			if [ ${ret} -eq 1 ]; then
				printf "${arg} is not installed, skipping '${*}' command\n\n"
				IFS=${old_IFS}
				return 1
			else
				change_origin=0
			fi
		fi
	done

	IFS=${old_IFS}
	return 0
}

display_usage() {
	<< EOF >&2 cat
Usage: ${0##*/} [-h|-w|-y]

    -h - show this help
    -w - wait for key press after finish
    -y - answer yes to all questions

EOF
	exit 1
}

get_entry_dates() {
	egrep "^[0-9]{8}:" ${PORTSDIR}/UPDATING | sed 's/://'
}

get_removed_ports() {
	awk -v date="${1}" '
	!/^#/ {
		n = split($0, field, "|");
		if (n != 4)
			next;

		gsub("-", "", field[3]);
		if (field[2] != "" || field[3] < date)
			next;

		print field[1];
	}' ${PORTSDIR}/MOVED
}

removal_reason() {
	awk -v port="${1}" '
	!/^#/ {
		n = split($0, field, "|");
		if (n != 4)
			next;

		if (field[1] == port)
			print field[4];
	}' ${PORTSDIR}/MOVED
}

updating_commands() {
	awk -v entry="${1}" '
	BEGIN {
		in_entry=0;
		in_cmd=0;
		cmd="";
	}

	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		sub(":", "", $0);
		if (entry == $0)
			in_entry=1;
		else
			if (in_entry == 1)
				exit;
	}

	{
		if (in_entry != 1)
			next;

		if (in_cmd == 0) {
			if (match($0, /^[ \t#]*pkg /))
				cmd = substr($0, index($0, "pkg "));
			if (match($0, /^[ \t#]*portmaster/))
				cmd = substr($0, index($0, "portmaster"));
			if (cmd == "")
				next;

			if (match(cmd, /\\$/)) {
				sub(/\\$/, "", cmd);
				in_cmd=1;
			} else {
				print cmd;
				cmd="";
			}
		} else {
			sub(/^[ \t]*/, "", $0);

			if (match($0, /\\$/)) {
				sub(/\\$/, "", $0);
				cmd=cmd $0;
			} else {
				print cmd $0;
				cmd="";
				in_cmd=0;
			}
		}
	}' ${PORTSDIR}/UPDATING
}

updating_entry() {
	echo ""
	awk -v entry="${1}" '
	BEGIN { in_entry=0; }
	
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		curr_entry=$0;
		sub(":", "", curr_entry);
		if (entry == curr_entry)
			in_entry=1;
		else
			if (in_entry == 1)
				exit;
	}

	{
		if (in_entry == 1)
			print $0;
	}' ${PORTSDIR}/UPDATING
	echo ""
}

# $1 - exit status
# $2 - last read/executed UPDATING entry
# $3 - wait for final keypress?
upgrade_exit() {
	[ -n "${2}" ] && echo ${2} > ${CONFIG}
	[ -n "${tmpfile}" -a -f "${tmpfile}" ] && rm -rf "${tmpfile}"

	if [ ${3} -eq 1 ]; then
		printf "\n===> Press Enter key to finish.\n\n"
		read key
	fi
	exit ${1}
}

while getopts "hwy" option; do
	case ${option} in
	w)
		wait_for_key=1 ;;
	y)
		portmaster_args="--no-confirm"
		answer_yes=1 ;;
	*)
		display_usage
	esac
done

[ -d "${PORTSDIR}" ] || \
	PORTSDIR="$(make -V PORTSDIR /usr/share/mk/bsd.ports.mk 2>/dev/null)"
if [ ! -d "${PORTSDIR}" ]; then
	echo "Ports directory not found: ${PORTSDIR}, try setting PORTSDIR variable" >&2
	exit 1
fi

if [ $(id -u) -ne 0 ]; then
	which sudo >/dev/null
	if [ ${?} -eq 1 ]; then
		echo "===> sudo not found" >&2
		upgrade_exit 1 "" ${wait_for_key}
	fi
	SUDO="sudo"
fi

which portmaster >/dev/null
if [ ${?} -eq 1 ]; then
	echo "===> portmaster not found" >&2
	upgrade_exit 1 "" ${wait_for_key}
fi

if [ -n "${UPGRADE_PORTS_IGNORE}" ]; then
	for pattern in ${UPGRADE_PORTS_IGNORE}; do
		portmaster_args="${portmaster_args} -x ${pattern}"
	done
fi

if [ -f "${CONFIG}" ]; then
	last_read="$(cat "${CONFIG}")"
else
	[ -d "${XDG_CONFIG_HOME}" ] || mkdir "${XDG_CONFIG_HOME}"
fi

[ -n "${last_read}" ] || last_read="$(get_entry_dates | head -n 1)"

${SUDO} portsnap fetch update
if [ ${?} -ne 0 ]; then
	echo "===> Ports tree update failed" >&2
	upgrade_exit 1 "" ${wait_for_key}
fi

for port in $(get_removed_ports ${last_read}); do
	pkg info -e ${port} 2>&1 >/dev/null
	if [ $? -eq 0 ]; then
		if ask_yesno "Remove obsolete ${port} ($(removal_reason ${port}))"
		then
			${SUDO} pkg delete -y ${port}
		fi
	fi
done

last_upd="$(get_entry_dates | head -n 1)"

if [ ${last_read} -lt ${last_upd} ]; then
	tmpfile="$(mktemp -t upgrade-ports)"
	if [ -z "${tmpfile}" ]; then
		echo "===> Failed to create temporary file" >&2
		upgrade_exit 1 "" ${wait_for_key}
	fi

	for entry in $(get_entry_dates | sort -u); do
		[ ${entry} -gt ${last_read} ] || continue
		
		updating_entry ${entry}
		updating_commands ${entry} > ${tmpfile}

		old_IFS=${IFS}
		IFS=$'\n'
		
		for cmd in $(cat ${tmpfile}); do
			command_is_relevant ${cmd} || continue
			case ${cmd} in "portmaster "*)
				cmd="${cmd} ${portmaster_args}"
			esac

			if ask_yesno "Run '${cmd}'"; then
				IFS=${old_IFS}
				${SUDO} ${cmd}
				ret=${?}
				IFS=$'\n'
				
				if [ ${ret} -ne 0 ]; then
					echo "===> Upgrade command '${cmd}' failed" >&2
					upgrade_exit ${ret} "${entry_prev}" ${wait_for_key}
				fi
			fi
		done
		
		IFS=${old_IFS}
		entry_prev="${entry}"
	done
	if [ ${answer_yes} -eq 0 ]; then
		ask_yesno "Update ports with 'portmaster -a'"
		[ ${?} -ne 0 ] && upgrade_exit 0 "${last_upd}" 0
	fi	
fi

${SUDO} portmaster -a ${portmaster_args}
upgrade_exit ${?} "${last_upd}" ${wait_for_key}

#!/bin/sh

readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly CONFIG="${XDG_CONFIG_HOME}/upgrade-ports"
readonly PAGER="${PAGER:-less}"

PORTSDIR=${PORTSDIR:-/usr/ports}

answer_yes=0	# answer yes to all of the questions
skip_update=0	# don't update ports tree
wait_for_key=0	# wait for key press after update finish

ask_yesno() {
	[ ${answer_yes} -eq 0 ] || return 0
	while true; do
		echo -n "${1} (y/n)? [y] "
		
		read answer
		[ "${answer}" ] || answer="y"

		case ${answer} in
		[Nn])
			return 1 ;;
		[Yy])
			return 0
		esac
	done
}

command_is_relevant() {
	local change_origin=0 old_IFS=${IFS} upgrade_prg=""

	IFS=" "
	for arg in ${*}; do
		[ "${upgrade_prg}" ] || upgrade_prg="${arg}"
		case ${arg} in
		"-a")
			if [ "${upgrade_prg}" = "portmaster" ]; then
				printf "===> Skipping upgrade of all packages for now (${*})\n\n"
				IFS=${old_IFS}
				return 1
			fi
			;;
		"-o")
			change_origin=1
			continue
		esac

		if [ ${change_origin} -ne 0 ]; then
			if [ "${upgrade_prg}" = "portmaster" -a \
				${change_origin} -eq 1 ]
			then
				change_origin=2
				continue
			fi
			if ! pkg_exists ${arg%:*}; then
				printf "===> ${arg} is not installed, skipping '${*}' command\n\n"
				IFS=${old_IFS}
				return 1
			else
				change_origin=0
			fi
		fi
	done

	IFS=${old_IFS}
	return 0
}

display_usage() {
	<< EOF >&2 cat
Usage: ${0##*/} [-h|-u|-w|-y]

    -h - show this help
    -u - don't update ports tree
    -w - wait for key press after finish
    -y - answer yes to all questions

EOF
	exit 1
}

get_entry_dates() {
	egrep "^[0-9]{8}:" ${PORTSDIR}/UPDATING | sed 's/://'
}

get_moved_ports() {
	awk -F '|' -v date="${1}" '
	!/^#/ && NR = 4 && $2 {
		gsub("-", "", $3);
		if ($3 > date)
			print $1 ":" $2;
	}' ${PORTSDIR}/MOVED
}

get_removed_ports() {
	awk -F '|' -v date="${1}" '
	!/^#/ && NR = 4 && !$2 {
		gsub("-", "", $3);
		if ($3 > date)
			print $1;
	}' ${PORTSDIR}/MOVED
}

pkg_exists() {
	[ "${1}" ] || return 1
	pkg-static info --exists ${1} 2>&1 >/dev/null
}

removal_reason() {
	awk -F '|' -v port="${1}" '
	!/^#/ && NR = 4 {
		if ($1 == port)
			print $4;
	}' ${PORTSDIR}/MOVED
}

updating_commands() {
	awk -v entry="${1}" '
	BEGIN {
		in_entry=0;
		in_cmd=0;
		cmd="";
	}
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		sub(":", "", $0);
		if (entry == $0)
			in_entry=1;
		else
			if (in_entry == 1)
				exit;
	}
	{
		if (in_entry != 1)
			next;

		if (in_cmd == 0) {
			if (match($0, /^[ \t#]*pkg /))
				cmd = substr($0, index($0, "pkg "));
			if (match($0, /^[ \t#]*portmaster/))
				cmd = substr($0, index($0, "portmaster"));
			if (cmd == "")
				next;

			if (match(cmd, /\\$/)) {
				sub(/\\$/, "", cmd);
				in_cmd=1;
			} else {
				print cmd;
				cmd="";
			}
		} else {
			sub(/^[ \t]*/, "", $0);

			if (match($0, /\\$/)) {
				sub(/\\$/, "", $0);
				cmd=cmd $0;
			} else {
				print cmd $0;
				cmd="";
				in_cmd=0;
			}
		}
	}' ${PORTSDIR}/UPDATING
}

updating_entry() {
	echo ""
	awk -v entry="${1}" '
	BEGIN { in_entry=0; }
	
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		curr_entry=$0;
		sub(":", "", curr_entry);
		if (entry == curr_entry)
			in_entry=1;
		else
			if (in_entry == 1)
				exit;
	}
	{
		if (in_entry == 1)
			print $0;
	}' ${PORTSDIR}/UPDATING
	echo ""
}

# $1 - exit status
# $2 - last read/executed UPDATING entry
# $3 - wait for final keypress?
upgrade_exit() {
	local keywait=${3}

	[ "${2}" ] && echo ${2} > ${CONFIG}
	[ "${keywait}" ] || keywait=${wait_for_key}
	[ "${tmpfile}" -a -f "${tmpfile}" ] && rm -rf "${tmpfile}"

	if [ ${keywait} -eq 1 ]; then
		printf "\n===> Press Enter key to finish.\n\n"
		read key
	fi
	exit ${1}
}

while getopts "huwy" option; do
	case ${option} in
	u)
		skip_update=1 ;;
	w)
		wait_for_key=1 ;;
	y)
		portmaster_args="--no-confirm"
		answer_yes=1 ;;
	*)
		display_usage
	esac
done

[ -d "${PORTSDIR}" ] ||
	PORTSDIR="$(make -V PORTSDIR /usr/share/mk/bsd.ports.mk 2>/dev/null)"
if [ ! -d "${PORTSDIR}" ]; then
	echo "===> Ports directory not found: ${PORTSDIR}, try setting PORTSDIR variable" >&2
	exit 1
fi

if [ $(id -u) -ne 0 ]; then
	if ! which sudo >/dev/null; then
		echo "===> sudo not found" >&2
		upgrade_exit 1
	fi
	SUDO="sudo"
fi
if ! which portmaster >/dev/null; then
	echo "===> portmaster not found" >&2
	upgrade_exit 1
fi

if [ "${UPGRADE_PORTS_IGNORE}" ]; then
	for pattern in ${UPGRADE_PORTS_IGNORE}; do
		portmaster_args="${portmaster_args} -x ${pattern}"
	done
fi

if [ -f "${CONFIG}" ]; then
	last_read="$(cat "${CONFIG}")"
else
	[ -d "${XDG_CONFIG_HOME}" ] || mkdir "${XDG_CONFIG_HOME}"
fi

[ "${last_read}" ] || last_read="$(get_entry_dates | head -n 1)"

if [ ${skip_update} -eq 0 ]; then
	if ! ${SUDO} portsnap fetch update; then
		echo "===> Ports tree update failed" >&2
		upgrade_exit 1
	fi
fi

for port in $(get_removed_ports ${last_read}); do
	if pkg_exists ${port}; then
		if ask_yesno "Remove obsolete ${port} ($(removal_reason ${port}))"
		then
			${SUDO} pkg-static delete --yes --force ${port}
		fi
	fi
done
for ports in $(get_moved_ports ${last_read}); do
	pkg_exists ${ports%%:*} &&
		${SUDO} pkg-static set --change-origin ${ports} --yes &&
		echo "===> Port ${ports%%:*} moved to ${ports##*:}"
done

last_upd="$(get_entry_dates | head -n 1)"

if [ ${last_read} -lt ${last_upd} ]; then
	tmpfile="$(mktemp -t ${0##*/})"
	if [ ! "${tmpfile}" ]; then
		echo "===> Failed to create temporary file" >&2
		upgrade_exit 1
	fi

	for entry in $(get_entry_dates | sort -u); do
		[ ${entry} -gt ${last_read} ] || continue
		
		updating_entry ${entry}
		updating_commands ${entry} > ${tmpfile}

		old_IFS=${IFS}
		IFS=$'\n'
		
		for cmd in $(cat ${tmpfile}); do
			command_is_relevant ${cmd} || continue
			case ${cmd} in "portmaster "*)
				cmd="${cmd} ${portmaster_args}"
			esac

			if ask_yesno "Run '${cmd}'"; then
				IFS=${old_IFS}
				${SUDO} ${cmd}
				ret=${?}
				IFS=$'\n'
				
				if [ ${ret} -ne 0 ]; then
					echo "===> Upgrade command '${cmd}' failed" >&2
					upgrade_exit ${ret} ${entry_prev}
				fi
			fi
		done
		
		IFS=${old_IFS}
		entry_prev="${entry}"
	done
	ask_yesno "Update ports with 'portmaster -a'" ||
		upgrade_exit 0 ${last_upd} 0
fi

${SUDO} portmaster -a ${portmaster_args} || upgrade_exit 1 ${last_upd}

echo "===> Checking packages for missing libraries/dependencies"
pkgs_rebuild=$(${SUDO} pkg-static check -dan | awk -v pkg_ignore="${UPGRADE_PORTS_IGNORE}" '
BEGIN {
	if ((n = split(pkg_ignore, array, " ")) > 0)
		for (i=1; i<=n; i++)
			ignore[array[i]] = array[i];
}

function pkg_is_ignored(pkg) {
	for (pattern in ignore)
		if (match(pkg, ".*" pattern ".*"))
			return 1;
	return 0;
}

/is missing a required shared library:/ {
	pkg=$1;
	if (pkg_is_ignored(pkg) || pkg in rebuild)
		next;
	rebuild[pkg] = pkg;
}

/has a missing dependency:/ {
	pkg=$6;
	if (pkg_is_ignored(pkg) || pkg in rebuild)
		next;

	"pkg-static rquery -e '\''%n = " pkg  "'\'' %o" | getline origin
	if (origin != "")
		rebuild[pkg] = origin;
}

END {
	for (i in rebuild)
		printf("%s ", rebuild[i]);
}')

if [ "${pkgs_rebuild}" ]; then
	for pkg in ${pkgs_rebuild}; do
		case pkg in
			*/*)
				inst="${pkg}" ;;
			*)
				rinst="${pkg}"
		esac
	done
	if [ "${inst}" ]; then
		printf "\nPorts need to be INSTALLED:\n"
		for port in ${inst}; do printf "  ${port}\n"; done
	fi
	if [ "${rinst}" ]; then
		printf "\nPackages need to be REINSTALLED:\n"
		for pkg in ${rinst}; do printf "  ${pkg}\n"; done
	fi
	ask_yesno "Continue with changes" &&
		${SUDO} portmaster ${portmaster_args} ${pkgs_rebuild}
fi
upgrade_exit ${?} ${last_upd}

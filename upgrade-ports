#!/bin/sh

readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly CONFIG="$XDG_CONFIG_HOME/upgrade-ports"
export readonly PORTSDIR=${PORTSDIR:-/usr/ports}

answer_yes=0	# answer yes to all of the questions
build_started=0 # ports build has started
interrupted=0   # build interrupted by ctrl+c
make_args="BATCH=yes DISABLE_LICENSES=yes DISABLE_VULNERABILITIES=yes"
skip_update=0	# don't update ports tree
wait_for_key=0	# wait for key press after upgrade finish

ask_yesno() {
	local answer

	[ $answer_yes -eq 0 ] || return 0
	while true; do
		printf "\n$1 (y/n)? [y] "

		read answer
		[ "$answer" ] || answer="y"

		case $answer in
		[Nn])
			return 1 ;;
		[Yy])
			return 0
		esac
	done
}

check_for_missing_deps() {
	local dep

	for dep in $(make -C "$PORTSDIR/$1" -VFETCH_DEPENDS -VEXTRACT_DEPENDS \
		-VPATCH_DEPENDS -VBUILD_DEPENDS -VLIB_DEPENDS -VRUN_DEPENDS |
		tr ' ' '\n' | cut -d':' -f2 | sort -u)
	do
		if ! pkg_exists $dep; then
			list_add need_install $dep
			list_add $(to_env_str $dep)_reqby $1
			list_add $(to_env_str $1)_mdeps $dep
			check_for_missing_deps $dep
		fi
	done
}

check_packages() {
	local pkg pkg_ignore

	echo "===> Checking packages for missing libraries/dependencies..."
	for pkg in $(pkg-static lock -lq); do
		list_add pkg_ignore $(pkg-static query %n $pkg)
	done
	eval $($SUDO pkg-static check -dan | awk -v pkg_ignore="$pkg_ignore" '
	function pkg_origin(pkg) {
		"pkg-static rquery %o " pkg | getline port
		close("pkg-static rquery %o " pkg);
		return port;
	}
	BEGIN {
		if ((n = split(pkg_ignore, array, " ")))
			for (i=1; i<=n; i++)
				ignore[array[i]] = array[i];
		while ("ldconfig -r" | getline line) {
			split(line, array);
			if (array[2] != "=>")
				continue;
			n = split(array[3], path, "/");
			libname = substr(path[n], 1, index(path[n], ".so") + 2);
			syslibs[libname] = array[3];
		}
	}
	/has a missing dependency:/ {
		if ($6 in ignore)
			next;
		miss_deps[$1] = $1;
		if ($6 in install) {
			install[$6] = install[$6] " " $1;
			next;
		}
		install[$6] = $1;
		missing = pkg_origin($6);
		inst = inst ? inst " " missing : missing;
	}
	/is missing a required shared library:/ {
		if ($1 in ignore || $1 in miss_deps)
			next;
		libname = substr($8, 1, index($8, ".so") + 2);
		if (libname in syslibs == 0) {
			print "===> " $1 " linked to " $8 ", not found on the system" > "/dev/stderr"
			next;
		}
		if ($1 in rebuild) {
			rebuild[$1] = rebuild[$1] " " $8;
			next;
		}
		rebuild[$1] = $8;
		origin = pkg_origin($1);
		rinst = rinst ? rinst " " origin : origin;
	}
	END {
		print "need_install=\"" inst "\" need_reinstall=\"" rinst "\"";
		for (pkg in install) {
			origin = pkg_origin(pkg);
			gsub(/(\/|-|\.|\+)/, "_", origin);
			print origin "_reqby=\"" install[pkg] "\"";
		}
		for (pkg in rebuild) {
			origin = pkg_origin(pkg);
			gsub(/(\/|-|\.|\+)/, "_", origin);
			print origin "_mlibs=\"" rebuild[pkg] "\"";
		}
	}')

	if [ "$need_install" -o "$need_reinstall" ]; then
		detect_conflicts
		print_list "Packages need to be REMOVED" $(to_rm_str $need_remove)
		print_list "Ports need to be INSTALLED" $(to_inst_str $need_install)
		print_list "Packages need to be REINSTALLED" $(to_mlibs_str $need_reinstall)
		if ask_yesno "Continue with changes"; then
			pkg_remove $need_remove
			rebuild_ports $need_install $need_reinstall
		fi
	fi
	upgrade_exit 0
}

command_is_valid() {
	local old_IFS=$IFS

	IFS=" "
	if [ "${*%% *}" = "pkg" ]; then
		cmd_pkg_validate ${*#pkg }
	else
		cmd_pm_validate ${*#portmaster }
	fi
	ret=$?
	IFS=$old_IFS
	return $ret
}

cmd_pkg_validate() {
	local cmd=${*%% *} exists=0 pkgname

	[ "$cmd" = "info" -o "$cmd" = "query" ] && return 1
	shift 1
	while getopts "fgn:o:y" opt; do
		case $opt in
		f|g|y)
			;;
		n|o)
			pkgname=${OPTARG%:*} ;;
		\?)
			echo "===> Pkg unhandled option"
			return 1
		esac
	done
	if [ ! "$cmd" = "set" ]; then
		shift $((OPTIND-1))
		pkgname=$*
	fi
	for pkg in $pkgname; do
		pkg_exists $pkg && exists=1
	done
	if [ $exists -eq 0 ]; then
		echo "===> $pkgname is not installed, skipping command"
		return 1
	fi
	return 0
}

cmd_pm_validate() {
	local cmdline change_origin=0 exists=0 pkg pkgname

	while getopts "Rafo:r:w" opt; do
		case $opt in
		a)
			echo "===> Skipping upgrade of all packages for now"
			return 1 ;;
		f|w|R)
			;;
		o)
			change_origin=1 ;;
		r)
			list_add pkgname $OPTARG ;;
		\?)
			echo "===> Portmaster unhandled option, skipping"
			return 1
		esac
	done
	shift $((OPTIND-1))
	if [ $change_origin -eq 1 ]; then
		pkgname=$*
	else
		case $* in
		'$('*')')
			cmdline=$(echo $* | sed 's|^\$(||' | sed 's|)$||') ;;
		"\`"*"\`")
			cmdline=$(echo $* | sed 's|`||g') ;;
		*)
			list_add pkgname $*
		esac
	fi
	if [ "$cmdline" ]; then
		[ "$($cmdline)" ] && return 0 || return 1
	fi
	for pkg in $pkgname; do
		pkg_exists $pkg && exists=1
	done
	if [ $exists -eq 0 ]; then
		echo "===> $pkgname is not installed, skipping command"
		return 1
	fi
	return 0
}

create_tmpfile() {
	local temp=$(mktemp -t ${0##*/}$1)

	if [ ! "$temp" ]; then
		echo "===> Failed to create temporary file" >&2
		upgrade_exit 1
	fi
	echo $temp
}

desc_pids() {
	local pids=$1 ret

	for pid in $(pgrep -P $1); do
		ret=$(desc_pids $pid)
		[ "$ret" ] && pids="$pids $ret"
	done
	echo $pids
}

detect_conflicts() {
	local cnfl origin port

	for port in $need_upgrade $need_install $need_reinstall; do
		check_for_missing_deps $port
	done

	for port in $need_upgrade $need_install $need_reinstall; do
		for cnfl in $(make -C "$PORTSDIR/$port" -VCONFLICTS \
			-VCONFLICTS_BUILD -VCONFLICTS_INSTALL)
		do
			for origin in $(pkg-static query -g %o "$cnfl"); do
				if [ "$port" = "$origin" ]; then
					list_add conflicts_self $port
				else
					mark_for_removal $origin "conflicts with $(to_pkg_str $port)"
				fi
			done
		done
	done
}

display_usage_install() {
	<< EOF >&2 cat
Usage: ${0##*/} -h
       ${0##*/} [-dy] pkg-name ...

    -d - build with debug support
    -h - show this help
    -y - answer yes to all questions

EOF
	exit 1
}

display_usage_reinstall() {
	<< EOF >&2 cat
Usage: ${0##*/} -h
       ${0##*/} [-dy] [-r pkg-name] pkg-name ...

    -d - build with debug support
    -h - show this help
    -r - reinstall pkg-name and all it's consumers
    -y - answer yes to all questions

EOF
	exit 1
}

display_usage_upgrade() {
	<< EOF >&2 cat
Usage:  ${0##*/} -c [-wy]
        ${0##*/} -h
	${0##*/} [-uwy]

    -c - only check packages database for errors
    -h - show this help
    -u - skip ports tree update
    -w - wait for key press after finish
    -y - answer yes to all questions

EOF
	exit 1
}

fetch_distfiles() {
	$SUDO sh -c "
		lockf -k $tmpfile sh -c \" echo PID:\$\$ >> $tmpfile\"
		for port in $*; do
			make -C \"$PORTSDIR/\$port\" checksum
			lockf -k $tmpfile sh -c \"echo \$port:\$? >> $tmpfile\"
		done
		lockf -k $tmpfile sh -c \" echo PID:0 >> $tmpfile\"
		" >/dev/null 2>&1 &
}

get_entry_dates() {
	egrep "^[0-9]{8}:" "$PORTSDIR/UPDATING" | sed 's/://'
}

list_add() {
	local arg name=$1 list=$(eval echo \$$1)

	shift 1
	for arg in $*; do
		list_find $name $arg && continue
		list="$list $arg"
	done
	setvar $name "$list"
}

list_find() {
	local elem

	for elem in $(eval echo \$$1); do
		[ "$elem" = "$2" ] && return 0
	done
	return 1
}

list_remove() {
	local elem name=$1 new_list

	for elem in $(eval echo \$$1); do
		[ "$elem" = "$2" ] || new_list="$new_list $elem"
	done
	setvar $name "$new_list"
}

mark_for_removal() {
	local port

	list_add need_remove $1
	setvar $(to_env_str $1)_conflicts "$2"
	for port in $(pkg-static query %ro $1); do
		mark_for_removal $port "depends on $(to_pkg_str $1)"
	done
}

missing_deps_recursive() {
	local port

	for port in $(eval echo \$$(to_env_str $1)_mdeps); do
		missing_deps_recursive $port
		list_add mdeps $port
	done
}

moved_reason() {
	awk -F '|' -v line="$moved_last" -v port="$1" '
		NR > line && $1 == port { print $4 }' "$PORTSDIR/MOVED"
}

pkg_exists() {
	[ "$1" ] || return 1
	pkg-static info --exists $1 >/dev/null 2>&1
}

pkg_remove() {
	local port

	[ "$*" ] || return
	for port in $*; do
		$SUDO pkg-static create --quiet \
			--out-dir "$PORTSDIR/packages/All" $port
		setvar $(to_env_str $port)_backup \
			"${PORTSDIR}/packages/All/$(to_pkg_str $port).txz"
	done
	$SUDO pkg-static delete --quiet --yes --force $*
}

pm_fake_run() {
	local new_origin port rports=""

	while getopts "Rfo:r:w" opt; do
		case $opt in
		f|w|R)
			;;
		o)
			new_origin=$OPTARG ;;
		r)
			list_add rports $(to_port_str $OPTARG)
			list_add rports $(pkg-static query %ro $OPTARG)
		esac
	done
	shift $((OPTIND-1))
	if [ "$new_origin" ]; then
		$SUDO pkg-static set -o $*:$new_origin --yes
		return $?
	fi
	list_add rports $(to_port_str $*)
	if [ "$rports" ]; then
		echo "===> Found packages to reinstall in later stage:"
		echo $rports
		list_add need_reinstall $rports
	fi
}

ports_upgrade_sort() {
	echo $* | tr ' ' '\n' | awk '
	function partition(a, s, e) {
		i = s-1; j = e+1;

		while(1) {
			do i++; while (i < n_ports+1 && ports_cmp(a[i], a[s]) < 0)
			do j--; while (j > -1 && ports_cmp(a[j], a[s]) > 0)

			if (i >= j)
				return j;

			tmp = a[i]; a[i] = a[j]; a[j] = tmp;
		}
	}
	function ports_cmp(a, b) {
		if (a == b)
			return 0;
		if (match(port_deps[b], a))
			return -1;
		if (match(port_deps[a], b))
			return 1;
		return port_ndeps[a] - port_ndeps[b];
	}
	function qsort(a, start, end) {
		if (start >= end)
			return;
		p = partition(a, start, end);
		qsort(a, start, p);
		qsort(a, p+1, end);
	}
	{
		ports[++n_ports] = $0;
		while ("make -C \"" ENVIRON["PORTSDIR"] "/" $0 "\" all-depends-list" | getline line) {
			sub(ENVIRON["PORTSDIR"] "/", " ", line);
			port_deps[$0] = port_deps[$0] line;
			port_ndeps[$0]++;
		}
		close("make -C \"" ENVIRON["PORTSDIR"] "/" $0 "\" all-depends-list");
	}
	END {
		qsort(ports, 1, n_ports);
		for(x=1; x<=n_ports; x++)
			print ports[x];
	}'
}

print_list() {
	local item title=$1

	[ "$2" ] || return
	shift 1
	printf "\n$title [$#]:\n"
	for item in $*; do printf "\t$item\n" | sed 's|@| |g'; done | sort
}

rebuild_error_clean() {
	if list_find conflicts_self $1; then
		echo "===> Restoring previous version from backup..."
		$SUDO pkg-static add --quiet \
			"$(eval echo \$$(to_env_str $1)_backup)"
	fi
	if [ $interrupted -eq 1 ]; then
		build_interrupted=$1
		$SUDO make clean
	else
		skip_reverse_deps $1 "$2 error"
	fi
}

rebuild_ports() {
	local errlog error full_queue make_cmd port queue ret=1 t
	local operation=$run_mode

	[ "$tmpfile" ] || tmpfile=$(create_tmpfile)
	if [ $# -gt 1 ]; then
		[ "$operation" = "check" ] && operation="reinstall"
		echo "===> Calculating ports $operation order..."
		queue=$(ports_upgrade_sort $*)
	else
		queue=$*
	fi
	for port in $queue; do
		[ -d "$PORTSDIR/$port" ] || continue
		mdeps=""
		missing_deps_recursive $port
		list_add full_queue $mdeps $port
	done
	if [ "$conflicts_self" ]; then
		echo "===> Backuping and removing self-conflicting packages..."
		pkg_remove $conflicts_self
	fi
	fetch_distfiles $full_queue
	errlog=$(create_tmpfile "-errlog")
	for port in $full_queue; do
		if [ $interrupted -eq 1 ]; then
			list_add build_skipped $port
			continue
		fi
		list_find build_skipped $port && continue

		cd "$PORTSDIR/$port"
		for t in BROKEN IGNORE; do
			error=$(make $make_args -V$t)
			if [ "$error" ]; then
				skip_reverse_deps $port "$t: $error"
				continue 2
			fi
		done

		if ! wait_for_distfiles $port; then
			skip_reverse_deps $port "failed to fetch"
			continue
		fi
		[ $build_started -eq 1 ] || build_started=1
		[ -d work ] && $SUDO make clean
		if ! $SUDO make $make_args build; then
			rebuild_error_clean $port build
			continue
		fi
		pkg_exists $port && make_cmd="reinstall" || make_cmd="install"
		while true; do
			$SUDO make $make_args $make_cmd clean 2>$errlog
			if [ $? -eq 0 ]; then
				ret=0
				break
			fi
			eval $(cat $errlog | awk '
				/conflicts with/ { print "CONFLICT=" $5 }')
			if [ "$CONFLICT" ]; then
				if ask_yesno "$port install conflicts with $CONFLICT. Remove it"; then
					pkg_remove $(pkg-static info -qo $CONFLICT)
					unset CONFLICT
					continue
				fi
			fi
			break
		done
		if [ $ret -ne 0 ]; then
			rebuild_error_clean $port install
		else
			list_add build_ok $port
		fi
	done
	rm $errlog
	if [ "$build_failed" -o "$build_interrupted" ]; then
		if [ $interrupted -eq 1 ]; then
			printf "\n===> Execution of $operation operation was interrupted.\n"
		else
			printf "\n===> Not all operations were successfull.\n"
		fi
		print_list "Following ports builds SUCCEEDED" $build_ok
		print_list "Following ports builds FAILED" $(to_fail_str $build_failed)
		print_list "Following build was INTERRUPTED" $build_interrupted
		print_list "Following ports builds were SKIPPED" $(to_fail_str $build_skipped)
		upgrade_exit 1 $last_upd
	fi
	unset conflicts_self need_install need_reinstall need_remove need_upgrade
}

show_operations_summary() {
	detect_conflicts

	print_list "Following packages need to be REMOVED" $(to_rm_str $need_remove)
	print_list "Following ports will be INSTALLED" $(to_inst_str $need_install)
	print_list "Following packages will be REINSTALLED" $(to_pkg_str $need_reinstall)
	print_list "Following packages will be UPGRADED" $(to_upgrade_str $need_upgrade)

	if ask_yesno "Proceed with $run_mode"; then
		pkg_remove $need_remove
		rebuild_ports $need_install $need_reinstall $need_upgrade
	else
		upgrade_exit 0 $last_upd
	fi
}

signal_handler() {
	local pids

	printf "\n===> Caught interrupt signal, cleaning up\n"
	interrupted=1
	if [ "$fetcher_pid" -a "$fetcher_pid" != "0" ]; then
		pids=$(desc_pids $fetcher_pid)
		$SUDO kill -9 $pids >/dev/null 2>&1
	fi
	[ $build_started -eq 0 ] || return
	upgrade_exit 1 $entry_prev
}

skip_reverse_deps() {
	local consumer rev_deps

	if ! list_find build_skipped $1; then
		list_add build_failed $1
		setvar $(to_env_str $1)_fail "$2"
	fi

	if pkg_exists $1; then
		rev_deps=$(pkg-static query %ro $1)
	else
		rev_deps=$(eval echo \$$(to_env_str $1)_reqby)
	fi
	for consumer in $rev_deps; do
		if list_find need_install $consumer ||
		   list_find need_reinstall $consumer ||
		   list_find need_upgrade $consumer;
		then
			list_add build_skipped $consumer
			setvar $(to_env_str $consumer)_fail "$1: $2"
			skip_reverse_deps $consumer "dependency skipped"
		fi
	done
}

to_env_str() {
	echo "$1" | sed -E 's,(\/|-|\.|\+),_,g'
}

to_fail_str() {
	local failure port str

	for port in $*; do
		failure=$(eval echo \$$(to_env_str $port)_fail | sed 's| |@|g')
		[ "$failure" ] && list_add str "$port@($failure)" ||
			list_add str $port
	done
	[ "$str" ] && echo $str
}

to_inst_str() {
	local port reqby str

	for port in $*; do
		reqby=$(eval echo \$$(to_env_str $port)_reqby | sed 's| |@|g')
		[ "$reqby" ] && list_add str "$port@(required@by@$reqby)" ||
			list_add str $port
	done
	[ "$str" ] && echo $str
}

to_mlibs_str() {
	local mlibs pkg port str

	for port in $*; do
		mlibs=$(eval echo \$$(to_env_str $port)_mlibs | sed 's| |@|g')
		pkg=$(to_pkg_str $port)
		list_add str "$pkg@(misses@libraries:@$mlibs)"
	done
	[ "$str" ] && echo $str
}

to_obs_str() {
	local port reason str

	for port in $*; do
		reason=$(moved_reason $port | sed 's| |@|g')
		list_add str "$(to_pkg_str $port)@($reason)"
	done
	[ "$str" ] && echo $str
}

to_pkg_str() {
	local pkg port str

	for port in $*; do
		pkg=$(pkg-static query "%n-%v" $port)
		[ "$pkg" ] || pkg=$port
		list_add str $pkg
	done
	[ "$str" ] && echo $str
}

to_port_str() {
	local arg str

	for arg in $*; do
		case $arg in
		*/*)
			[ -d "$PORTSDIR/$arg" ] && list_add str $arg ;;
		*)
			list_add str $(pkg-static query -x %o ^$arg)
		esac
	done
	[ "$str" ] && echo $str
}

to_rm_str() {
	local port reason str

	for port in $*; do
		reason=$(eval echo \$$(to_env_str $port)_conflicts | sed 's| |@|g')
		list_add str "$(to_pkg_str $port)@($reason)"
	done
	[ "$str" ] && echo $str
}

to_upgrade_str() {
	local curr new_ver port str

	for port in $*; do
		curr=$(pkg-static query "%n:@%v" $port)
		new_ver=$(eval echo \$$(to_env_str $port)_version)
		list_add str "$curr@->@$new_ver"
	done
	[ "$str" ] && echo $str
}

update_ports_tree() {
	local last_entry=$(tail -n 1 "$PORTSDIR/MOVED")
	local moved_lines=$(wc -l "$PORTSDIR/MOVED" | awk '{ print $1 }')
	local line_n newname oldname port ports

	[ $skip_update -eq 0 ] || return

	if ! $SUDO portsnap fetch update; then
		echo "===> Ports tree update failed" >&2
		upgrade_exit 1
	fi
	line_n=$(grep -n "$last_entry" "$PORTSDIR/MOVED" | cut -d: -f1)
	[ "line_n" ] && moved_last=$line_n || moved_last=$moved_lines

	for port in $(awk -F '|' -v line="$moved_last" '
		NR > line && !$2 { print $1 }' "$PORTSDIR/MOVED")
	do
		pkg_exists $port && list_add obsolete $port
	done
	print_list "Following packages are marked as OBSOLETE" $(to_obs_str $obsolete)
	for port in $obsolete; do
		ask_yesno "Remove $(to_pkg_str $port)" &&
			$SUDO pkg-static delete --quiet --yes --force $port
	done
	for ports in $(awk -F '|' -v line="$moved_last" '
		NR > line && $2 { print $1 ":" $2 }' "$PORTSDIR/MOVED")
	do
		if pkg_exists ${ports%%:*}; then
			oldname=$(pkg-static query %n ${ports%%:*})
			newname=$(make -C "$PORTSDIR/${ports##*:}" -VPKGBASE)
			[ "$newname" ] || continue
			echo "===> ${ports%%:*} moved to ${ports##*:} ($(moved_reason ${ports%%:*}))"
			[ "$oldname" != "$newname" ] &&
				$SUDO pkg-static set --change-name $oldname:$newname --yes
			$SUDO pkg-static set --change-origin $ports --yes
		fi
	done
}

updating_commands() {
	awk -F ':' -v entry="$1" '
	function strip_command(str) {
		sub("^[ \t#]*", "", str);
		in_cmd = sub(/\\$/, "", str);
		return str;
	}
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		if (entry == $1)
			in_entry=1;
		else if (in_entry)
			exit;
	}
	in_entry && !in_cmd {
		if (match($0, /^[ \t#]*(pkg|portmaster) /)) {
			cmd = strip_command($0);
			if (!in_cmd) {
				if (!match(cmd, "^pkg upgrade"))
					print cmd;
				cmd="";
			}
		}
		next;
	}
	in_entry && in_cmd {
		line = strip_command($0);
		if (in_cmd)
			cmd=cmd line;
		else {
			print cmd line;
			cmd="";
		}
	}' "$PORTSDIR/UPDATING"
}

updating_entry() {
	awk -F ':' -v entry="$1" '
	/^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]:/ {
		if (entry == $1)
			in_entry=1;
		else if (in_entry)
			exit;
	}
	in_entry { print $0 }' "$PORTSDIR/UPDATING"
}

# $1 - exit status
# $2 - last read/executed UPDATING entry
# $3 - wait for final keypress?
upgrade_exit() {
	local keywait=$3

	[ "$2" ] && echo $2 > "$CONFIG"
	[ "$keywait" ] || keywait=$wait_for_key
	[ "$tmpfile" -a -f "$tmpfile" ] && rm -rf "$tmpfile"

	if [ $keywait -eq 1 ]; then
		printf "\n===> Press Enter key to finish.\n\n"
		read key
	fi
	exit $1
}

upgrade_ports() {
	last_upd=$(get_entry_dates | head -n 1)

	if [ $last_read -lt $last_upd ]; then
		tmpfile=$(create_tmpfile)
		printf "===> New entries since last upgrade in $PORTSDIR/UPDATING file:\n\n"
		for entry in $(get_entry_dates | sort -u); do
			[ $entry -gt $last_read ] || continue

			updating_entry $entry
			updating_commands $entry > $tmpfile

			old_IFS=$IFS
			IFS=$'\n'

			for cmd in $(cat $tmpfile); do
				command_is_valid $cmd || continue

				if ask_yesno "Run '$cmd'"; then
					IFS=$old_IFS
					case $cmd in
					"pkg "*)
						$SUDO $cmd ;;
					*)
						pm_fake_run ${cmd#portmaster }
					esac
					ret=$?
					IFS=$'\n'

					if [ $ret -ne 0 ]; then
						echo "===> Upgrade command '$cmd' failed" >&2
						upgrade_exit $ret $entry_prev
					fi
				fi
			done

			IFS=$old_IFS
			entry_prev=$entry
		done
	fi

	echo "===> Checking for ports needing upgrade..."
	for port in $(pkg-static version -o -l '<' | cut -f1 -d' '); do
		[ "$(pkg-static info -kq $port)" = "yes" ] && continue
		list_add need_upgrade $port
		setvar $(to_env_str $port)_version \
			$(make -C "$PORTSDIR/$port" -VPKGVERSION)
		list_remove need_reinstall $port
		[ "$(make -C "$PORTSDIR/$port" -VPKGBASE)" != "$(pkg-static query %n $port)" ] &&
			list_add conflicts_self $port
	done
	if [ ! "$need_upgrade" ]; then
		echo "===> No ports needing upgrade found"
		upgrade_exit 0 $last_upd
	fi
	show_operations_summary
}

wait_for_distfiles() {
	local done=0 f_res=0 fetched=$(eval echo \$$(to_env_str $1)_fetch)
	local msg_shown=0 res

	[ "$fetched" ] && return $fetched

	while true; do
		for res in $(lockf -k $tmpfile sh -c "
			[ -s \"$tmpfile\" ] || exit
			cat $tmpfile
			echo > $tmpfile");
		do
			if [ "${res%:*}" = "PID" ]; then
				fetcher_pid=${res#*:}
				continue
			fi
			setvar $(to_env_str ${res%:*})_fetch ${res#*:}
			if [ "${res%:*}" = "$1" ]; then
				done=1
				f_res=${res#*:}
			fi
		done
		[ $interrupted -eq 0 ] || return 1
		[ $done -eq 0 ] || return $f_res
		if [ $msg_shown -eq 0 ] ; then
			echo "===> Waiting for $1 distfiles to fetch..."
			msg_shown=1
		fi
		sleep 5
	done
}

trap signal_handler INT

case ${0##*/} in
	pinstall)
		run_mode="install"
		while getopts "dhy" option; do
			case $option in
			d)
				make_args="$make_args WITH_DEBUG=yes" ;;
			y)
				answer_yes=1 ;;
			*)
				display_usage_install
			esac
		done
		shift $((OPTIND-1)) ;;
	preinstall)
		run_mode="reinstall"
		while getopts "dhr:y" option; do
			case $option in
			d)
				make_args="$make_args WITH_DEBUG=yes" ;;
			r)
				origin=$(pkg-static info -qo $OPTARG)
				if [ ! "$origin" ]; then
					printf "$OPTARG: no such package\n\n" >&2
					display_usage_reinstall
				fi
				list_add need_reinstall $origin
				list_add need_reinstall $(pkg-static query %ro $origin)
				;;
			y)
				answer_yes=1 ;;
			*)
				display_usage_reinstall
			esac
		done
		shift $((OPTIND-1)) ;;
	upgrade-ports)
		run_mode="upgrade"
		while getopts "chuwy" option; do
			case $option in
			c)
				run_mode="check" ;;
			u)
				skip_update=1 ;;
			w)
				wait_for_key=1 ;;
			y)
				answer_yes=1 ;;
			*)
				display_usage_upgrade
			esac
		done ;;
	*)
		echo "===> ${0##*/}: bad frontend name" >&2
		exit 1
esac

if [ ! -d "$PORTSDIR" ]; then
	echo "===> Ports directory not found: $PORTSDIR" >&2
	echo "===> Try setting PORTSDIR enviroment variable" >&2
	exit 1
fi

if [ $(id -u) -ne 0 ]; then
	if ! which sudo >/dev/null; then
		echo "===> sudo not found" >&2
		echo "===> This script requires root privileges or properly configured sudo." >&2
		upgrade_exit 1
	fi
	SUDO="sudo"
fi

case $run_mode in
check)
	check_packages ;;
install)
	[ "$*" ] || display_usage_install
	echo "===> Checking ports selected for install..."
	for pattern in $*; do
		case $pattern in
		*/*)
			[ -d "$PORTSDIR/$pattern" ] || continue
			pkg_exists $pattern && continue
			list_add need_install $pattern ;;
		*)
			for port in $(pfind -n $pattern); do
				pkg_exists $port && continue
				list_add need_install $port
			done
		esac
	done
	if [ ! "$need_install" ]; then
		echo "===> No suitable ports to install found" >&2
		upgrade_exit 1
	fi
	show_operations_summary ;;
reinstall)
	[ "$need_reinstall" -o "$*" ] || display_usage_reinstall
	echo "===> Checking ports selected for reinstall..."
	for pattern in $*; do
		case $pattern in
		*/*)
			pkg_exists $pattern || continue
			list_add need_reinstall $pattern ;;
		*)
			for port in $(pfind -n $pattern); do
				pkg_exists $port || continue
				list_add need_reinstall $port
			done
		esac
	done
	if [ ! "$need_reinstall" ]; then
		echo "===> No suitable packages to reinstall found" >&2
		upgrade_exit 1
	fi
	show_operations_summary ;;
upgrade)
	if [ -f "$CONFIG" ]; then
		last_read=$(cat "$CONFIG")
	else
		[ -d "$XDG_CONFIG_HOME" ] || mkdir "$XDG_CONFIG_HOME"
	fi
	[ "$last_read" ] || last_read=$(get_entry_dates | head -n 1)

	update_ports_tree
	upgrade_ports
	check_packages
esac

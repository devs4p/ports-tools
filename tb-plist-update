#!/bin/sh

readonly PAGER=${PAGER:-less}
readonly PKGNAME=$(make -V PKGNAME 2>/dev/null)
readonly TBDIR=${TBDIR:-/usr/local/tinderbox}
readonly UID=$(id -u)

tc_cmd() {
	local tc_script
	
	if [ $UID -eq 0 ]; then
		tc_script="./tc"
	else
		tc_script="sudo ./tc"
	fi

	cd $TBDIR/scripts && $tc_script $*
}


if [ -z "$(whereis -bq plist-sort)" ]; then
	echo "===> Required script plist-sort not found"
	exit
fi

if [ -z "$PKGNAME" ]; then
	echo "===> This is not port directory"
	exit
fi

builds=$1
if [ -z "$builds" ]; then
	builds=$(tc_cmd listBuilds)
	for build in $builds; do
		if [ -f "$TBDIR/logs/$build/$PKGNAME.log" ]; then
			logfile="$TBDIR/logs/$build/$PKGNAME.log"
			break
		fi
	done
	
	if [ -z "$logfile" ]; then
		echo "===> Could not find any build logs for $PKGNAME"
		exit
	fi
else
	logfile="$TBDIR/logs/$builds/$PKGNAME.log"
	if [ ! -f "$logfile" ]; then
		echo "===> Logfile $logfile does not exist"
		exit
	fi
fi

tempfile=$(mktemp)
if [ -f pkg-plist ]; then
	plist_out=pkg-plist.new
else
	plist_out=pkg-plist
fi

awk -v prefix="$(make -V PREFIX 2>/dev/null)/" '

function str_replace(string, pattern, new_pattern) {
	new_str=""
	n = split(string, array, pattern);
	if (n > 1) {
		for (i=1; i <= n; i++) {
			if (i != n)
				new_str = new_str array[i] new_pattern;
			else
				new_str = new_str array[i];
		}
	} else
		return string;

	return new_str;
}

BEGIN {
	x=1;

	while ((getline line < "pkg-plist") > 0) {
		lines[x++] = line;
		n = split(line, token, "%%");
		if (n == 1)
			continue;

		for (i=2; i<=n; i+=2) {
			if (token[i] != "")
				tmp[token[i]] = token[i];
		}
	}
	close("pkg-plist");

	for (t in tmp) {
		if (match(t, "^PYTHON_")) 
			make_args = " USE_PYTHON=yes";
		else if (match(t, "^(RUBY|GEM_)"))
			make_args = " USE_RUBY=yes";

		"make -V " t make_args| getline str;
		if (str != "") {
			subs[t] = str_replace(str, prefix, "");   # remove prefix
			#print t "=" subs[t];
		}
		close("make -V " t make_args);
		make_args = "";
	}
	
	for (l in lines) {
		line = lines[l];
		n = index(line, "@dirrm");
		if (n > 0) {
			i = split(substr(line,n), p,  " ");
			plist[ p[2] ] = line;
		} else {
			path = line;
			i = split(line, p, "%%");
			if (i == 1) {
				plist[line] = line;
				continue;
			}
			for (y=2; y<=i; y+=2) {
				if (subs[p[y]] == "")
					path = str_replace(path, "%%" subs[p[y]] "%%", "");
				else
					break;
			}
			plist[path] = line;
		}
	}
}

/^===>  Building package/, /^(tar: Error exit|pkg_delete: couldn|====)/ {
	n = split($0, p, ":");
	if (n < 4)
		next;

	path = substr(p[2], 2);
	for (str in subs) {
		if (subs[str] != "")
			path = str_replace(path, subs[str], "%%" str "%%");
	}
	
	if (plist[path] != "")
		delete plist[path];
}

/not present on clean system/, /^(cmp:|====)/ {
	#print "New file: " $11;

	if (!match($11, "^usr/local"))
		next;

	path = str_replace($11, "usr/local/", "");
	if (match(path,"^(man|info)/")) # ignore info and manpages
		next;

	for (str in subs) {
		if (subs[str] != "")
			path = str_replace(path, subs[str], "%%" str "%%");
	}
	if (plist[path] == "") {
		if (substr($3,1,1) == "d") {
			if (match(path, "^share/(applications|icons|locale|mime)"))
				plist[path] = "@dirrmtry " path;
			else
				plist[path] = "@dirrm " path;
		} else
			plist[path] = path;
	}
}

END {
	for (file in plist) {
		if (plist[file] != "") {
			print plist[file];
			#printf("file <%s> var <%s>\n", file, plist[file]);
		}
	}

}' $logfile > $tempfile

plist-sort $tempfile > $plist_out
rm $tempfile
[ "$plist_out" = "pkg-plist" ] && exit

if [ -n "$(cmp pkg-plist $plist_out 2>/dev/null)" ]; then
	diff -u pkg-plist $plist_out | $PAGER
	
	while true; do
		echo -n "Use newly generated plist (y/n)? "
		read cmd
		
		case $cmd in
		[Yy])
			mv $plist_out pkg-plist
			break ;;
		[Nn])
			break
		esac
	done
else
	rm $plist_out
fi

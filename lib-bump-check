#!/bin/sh

readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly IGNORE_FILE="${XDG_CONFIG_HOME}/lib-bump-check"
readonly LOCALBASE="${LOCALBASE:-/usr/local}"

bump_ignore=0

check_package() {
	local javavm pkg="${1}"

	local libs="$(pkg-static info -lq ${pkg} | while read file; do
		[ -L "${file}" ] && continue
		ldd "${file}" 2>/dev/null | awk '/not found/ { print $1 }'
	done | sort -u)"
	[ -z "${libs}" ] && return

	local pkg_files="$(pkg-static info -lq ${pkg})"
	for lib in ${libs}; do 
		case ${pkg_files} in *${lib}*)
			continue
		esac
		if [ -z "${javavm}" ]; then
			javavm="$(pkg-static info -dq ${pkg} | egrep 'jdk|jre')"
			[ -z "${javavm}" ] && javavm="no"
		fi
		[ "${javavm}" != "no" ] && \
			[ -n "$(pkg-static info -lq ${javavm} | grep ${lib})" ] && \
			continue
		echo -n "${lib} "
	done
}

display_usage() {
	<< EOF cat
Usage: lib-bump-check [-b] [-h] [-j jobs] [-r pkgname]

    -b - disable check for library newer version
    -j - set number of parallel checks to jobs
    -h - show this help
    -r - check only packages that depend on pkgname

EOF
	exit
}

exit_clean() {
	[ -f "${TMP_SEM}" ] && rm -f "${TMP_SEM}"
	[ -f "${TMP_STALE}" ] && rm -f "${TMP_STALE}"
	[ -f "${TMP_BAD}" ] && rm -f "${TMP_BAD}"
	exit ${1}
}

job_free() {
	lockf -k "${TMP_SEM}" sh -c "
		state=\$((\$(cat '${TMP_SEM}') + 1))
		echo \$state > '${TMP_SEM}'
	"
}

job_register() {
	while ! lockf -k "${TMP_SEM}" sh -c "
			state=\$(cat '${TMP_SEM}')
			if [ \$state -gt 0 ]; then
				echo \$((state - 1)) > '${TMP_SEM}'
				printf \"%-80s\\rChecking (%s/%s): ${pkg}\\r\" '' ${1} ${2} > /dev/tty
				exit 0
			fi
			exit 1
		"; do
		sleep 0.1
	done
}

jobs_finish_wait() {
	while ! lockf -k "${TMP_SEM}" sh -c "
			state=\$(cat '${TMP_SEM}')
			[ \$state -eq ${JOBS} ] && exit 0 || exit 1
		"; do
		sleep 0.1
	done
}

newer_library_available() {
	local lib="${1}"
	
	[ ${bump_ignore} -eq 0 ] || return 1

	local ret="$(ldconfig -r | awk -v so_ver="${lib##*.}" '
		BEGIN { so_bump=0; }

		/'${lib%.*}'/ {
			n_path = split($0, path, "/");
			n_libname = split(path[n_path], libname, ".");
	
			ret = libname[n_libname] - so_ver;
			if (ret > so_bump)
				so_bump=ret;
		}
		
		END { print so_bump; }
	')"
	return ${ret}
}

pkg_is_ignored() {
	local pkg="${1}"
	[ -n "${pkg_ignore}" ] || return 1

	for ignored in ${pkg_ignore}; do
		case ${pkg} in *${ignored}*) return 0 ;; esac
	done
	
	return 1
}

while getopts "bj:hr:" option; do
	case ${option} in
	b)
		bump_ignore=1 ;;
	j)
		[ -n "${OPTARG}" ] || display_usage
		case ${OPTARG} in
		[1-9])
			JOBS="${OPTARG}" ;;
		*)
			echo "-j requires numerical argument"
			exit 1
		esac ;;
	r)
		[ -n "${OPTARG}" ] || display_usage
		PKG_PARENT="${OPTARG}" ;;
	*)
		display_usage
	esac
done

if [ ! -x "${LOCALBASE}/sbin/portmaster" ]; then
	echo "This script requires portmaster"
	exit 1
fi

if [ "$(id -u)" != "0" ]; then
	echo "You need root privileges to rebuild packages"
	exit 1
fi

[ -n "${JOBS}" ] || JOBS="$(sysctl -n hw.ncpu 2>/dev/null || echo 1)"

if [ -n "${PKG_PARENT}" ]; then
	packages="$(pkg-static info -rq ${PKG_PARENT} 2>/dev/null)"
else
	packages="$(pkg-static query '%n-%v' 2>/dev/null)"
fi

pkg_all="$(echo ${packages} | wc -w)"
if [ ${pkg_all} -eq 0 ]; then
	echo "No packages to check found"
	exit
fi

pkg_curr=0

readonly TMP_SEM="$(mktemp -t lbc-sem)"
readonly TMP_STALE="$(mktemp -t lbc-stale)"
readonly TMP_BAD="$(mktemp -t lbc-bad)"

if [ -z "${TMP_SEM}" -o -z "${TMP_STALE}" -o -z "${TMP_BAD}" ]; then
	echo "Failed to create temporary files"
	exit_clean 1
fi

trap 'exit_clean 0' int

if [ -f "${IGNORE_FILE}" ]; then
	n=0
	pkg_ignore="$(grep -v '^#' "${IGNORE_FILE}")"
	for pkg in ${pkg_ignore}; do n=$((n+1)); done
	[ ${n} -eq 0 ] || echo "Read ${IGNORE_FILE}, ${n} entries found"
fi

lockf -k "${TMP_SEM}" echo ${JOBS} > "${TMP_SEM}"

for pkg in ${packages}; do
	pkg_curr=$((pkg_curr+1))
	pkg_is_ignored ${pkg} && continue

	job_register ${pkg_curr} ${pkg_all}
	(
		trap 'job_free' EXIT
		
		ret="$(check_package ${pkg})"
		[ -z "${ret}" ] && exit

		for lib in ${ret}; do
			newer_library_available ${lib}
			if [ ${?} -lt 1 ]; then
				echo ${pkg} >> ${TMP_BAD}
				exit
			fi
		done
		echo "${pkg}@${ret}" | sed 's| |@|g' >> ${TMP_STALE}
	) &
done
jobs_finish_wait
printf "\n\n"

pkg_bad_deps="$(cat ${TMP_BAD})"
if [ -n "${pkg_bad_deps}" ]; then
	printf "Following packages were ignored due probable packaging problems:\n\n"
	echo "${pkg_bad_deps}" | fmt -w 78
	echo ""
fi

pkg_stale="$(cat ${TMP_STALE})"
if [ -z "${pkg_stale}" ]; then
	printf "No packages linked to stale libs found\n\n"
	exit_clean 0
fi

printf "Following packages are linked to stale libs:\n\n"
for pkg in ${pkg_stale}; do
	pkg_re="${pkg_re} ${pkg%%@*}"
	echo "   ${pkg%%@*} => ${pkg#*@}" | sed 's|@| |g'
	n_stale=$((n_stale+1))
done

while true; do
	printf "\nTotal: ${n_stale} package(s)"
	echo -e "Do you want to reinstall them (y/n)? [y] \c"
	read answer
	[ -n "${answer}" ] || answer="y"

	case ${answer} in	
	[Nn])
		break ;;
	[Yy]) 
		${LOCALBASE}/sbin/portmaster -R --no-confirm ${pkg_re}
		break
	esac
done

exit_clean 0

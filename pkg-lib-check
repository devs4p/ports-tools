#!/bin/sh

first_result=1
full_check=0
only_link_err=0
show_direct_deps=0
test_all=0

# $1 - package to check
# $2 - print link errors
check_for_link_errors() {
	PKG_DEPS=""
	local package=$1 javavm link_leftover link_noexist

	local pkg_libs=$(pkg info -lq $package | while read file; do
		[ -L "$file" ] && continue

		ldd "$file" 2>/dev/null | awk '/=>/ {
			if (!match($3,"^(/lib|/usr/lib)"))
				if ($3 == "not")
					print "not_found" $1;
				else
					print $3;
			}'
	done | sort -u)

	local pkg_files=$(pkg info -lq $package 2>/dev/null)

	for lib in $pkg_libs; do
		case $lib in *..*)
			lib=$(realpath "$lib")
		esac
		# skip libraries from package we are checking
		case $pkg_files in *${lib##not_found}*)
			continue
		esac

		# library not found on system
		case $lib in not_found*)
			if [ -z "$javavm" ]; then
				javavm=$(pkg info -dq $package | egrep "jdk|jre")
				[ -z "$javavm" ] && javavm="no"
			fi

			[ "$javavm" != "no" ] && \
			[ -n "$(pkg info -lq $javavm | grep ${lib##not_found})" ] && \
				continue
		
			[ $show_direct_deps -eq 0 ] && \
				link_noexist="$link_noexist ${lib##not_found}"
			continue
		esac

		lib_owner=$(pkg which -q $lib 2>/dev/null);

		# skip false positive libGL - this library is shared between packages
		if [ $? -ne 70 -a "${lib%%*/lib/libGL.so.*}" ]; then
			[ $show_direct_deps -eq 0 ] && \
				link_leftover="$link_leftover $lib"
			continue
		fi

		case $PKG_DEPS in
		*$lib_owner*)
			;;
		*)
			PKG_DEPS="$PKG_DEPS $lib_owner"
		esac
	done
	
	[ $2 -eq 0 ] && return 0
	[ -z "$link_noexist" -a -z "$link_leftover" ] && return 0
	
	print_header $package
	for err in $link_noexist; do 
		echo "linked to non existent: $err"
	done | sort -u
	for err in $link_leftover; do
		echo "linked to leftover: $err"
	done | sort -u
	
	return 1
}

# $1 - package to check
# $2 - package dependencies
check_for_missing_deps() {
	local package=$1 deps=$2 missing_deps

	[ $show_direct_deps -eq 0 ] && \
		registered_deps=$(pkg info -dq $package 2>/dev/null)
	for dep in $deps; do
		case $registered_deps in
		*$dep*)
			;;
		*)
			missing_deps="$missing_deps $dep"
		esac
	done

	[ -z "$missing_deps" ] && return

	all_deps=$(pkg info -dq $missing_deps | sort -u)
	for dep in $missing_deps; do
		case $all_deps in
		*$dep*)
			;;
		*)
			echo $dep
		esac
	done | sort
}

check_registered_deps() {
	local broken=0 dep
	
	for dep in $(pkg info -dq $1); do
		pkg info -e $dep 2>/dev/null
		if [ $? -ne 0 ]; then
			echo "non-existent dependency: $dep"
			broken=1
		fi
	done
	
	[ $broken -eq 1 ] &&
		echo "===> Wrong dependencies, checks may return false data"
}

dependency_is_inherited() {
	local pkg=$1 dep=$2 inh

	for p_dep in $(pkg info -dq $pkg); do
		case $PKG_DEPS_OK in *$p_dep*)
			continue
		esac
		
		check_for_link_errors $p_dep 0
		ret_deps=$(check_for_missing_deps $p_dep "$PKG_DEPS")

		[ -z "$ret_deps" ] && PKG_DEPS_OK="$PKG_DEPS_OK $p_dep"
		
		case $ret_deps in
		*$dep*)
			if [ -n "$inh" ]; then
				[ -z "$(pkg info -rq $inh | grep $p_dep)" ] && \
					inh=$p_dep
			else
				inh=$p_dep
			fi
		esac
	done

	if [ -n "$inh" ]; then
		INH=$(pkg info -qo $inh)
	else
		INH=""
	fi
}

display_usage() {
	echo "Usage: pkg-lib-check [-d|-f|-l|-s grep_pattern] <-a|pkg_name>"
	echo ""
	echo "    -a - test all installed packages"
	echo "    -d - show direct dependencies"
	echo "    -f - do full checks with inheritance detection (slow)"
	echo "    -l - check only for link problems"
	echo "    -s - show files linked to 'grep_pattern'"
	echo ""
	exit
}

# $1 - package name
# $2 - search string
find_linked_to() {
	local package=$1 query=$2

	local ret=$(pkg info -lq $package | while read file; do
		[ -L "$file" ] && continue
	
		[ -n "$(ldd "$file" 2>/dev/null | grep -i ".*$query.*=>")" ] \
			&& echo $file
	done)
	[ -z "$ret" ] && return
	
	print_header $package
	for file in $ret; do echo $file; done
}

# $1 - package name
print_header() {
	if [ $first_result -eq 1 ]; then
		first_result=0
	else		
		echo ""
	fi
	echo "$1:"
}

while getopts "adfls:" option; do
	case $option in
	a)
		test_all=1 ;;
	d)
		[ $full_check -eq 1 -o $only_link_err -eq 1 -o \
			-n "$search_str" ] && display_usage
		show_direct_deps=1 ;;
	f)
		[ $show_direct_deps -eq 1 -o $show_direct_deps -eq 1 -o \
			-n "$search_str" ] && display_usage		
		full_check=1 ;;
	l)
		[ $show_direct_deps -eq 1 -o $full_check -eq 1 -o \
			-n "$search_str" ] && display_usage
		only_link_err=1 ;;
	s)
		[ $show_direct_deps -eq 1 -o $full_check -eq 1 -o \
			$only_link_err -eq 1 -o -z "$OPTARG" ] && display_usage
		search_str=$OPTARG ;;
	?)
		display_usage
	esac
done

if [ $test_all -eq 0 ]; then
	shift $(($OPTIND-1))
	packages=$@
	[ -z "$packages" ] && display_usage
else
	packages=$(pkg query '%n-%v')
	if [ -z "$packages" ]; then
		echo "No packages installed"
		exit
	fi
fi

[ $show_direct_deps -eq 0 ] && prefix="missing "

for pkg in $packages; do 
	if [ $test_all -eq 0 ]; then
		pkg info -e $pkg 2>/dev/null
		if [ $? -ne 0 ]; then
			echo "$pkg: no such package"
			continue
		fi
	fi
	if [ -n "$search_str" ]; then
		find_linked_to $pkg $search_str
		continue
	fi

	[ $full_check -eq 1 ] && check_registered_deps $pkg	

	check_for_link_errors $pkg 1
	link_errors=$?

	[ $only_link_err -eq 1 ] && continue

	m_deps=$(check_for_missing_deps $pkg "$PKG_DEPS")
	[ $link_errors -eq 0 -a -n "$m_deps" ] && print_header $pkg

	for md in $m_deps; do
		[ $full_check -eq 1 ] && dependency_is_inherited $pkg $md 

		if [ -z "$INH" ]; then
			echo $prefix"dependency: $(pkg info -qo $md)"
		else
			echo "missing dependency: $(pkg info -qo $md) (inherited from $INH)"
		fi
	done
done

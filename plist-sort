#!/bin/sh

readonly PKGNAME="$(make -V PKGNAME 2>/dev/null)"
readonly PREFIX="$(make -V PREFIX 2>/dev/null)"
plist_file="${1}"

if [ -z "${PKGNAME}" -o -z "${PREFIX}" ]; then
	echo "===> This is not port directory" >&2
	exit 1
fi

[ -n "${plist_file}" ] || plist_file=$(make -V PLIST)

if [ ! -f "${plist_file}" ]; then
	echo "===> Plist file was not found: ${plist_file}" >&2
	exit 1
fi

make_args="OPTIONSFILE=/dev/null OPTIONS_FILE=/dev/null"

for opt in $(make -VCOMPLETE_OPTIONS_LIST); do
	make_args="${make_args} WITHOUT_${opt}=true"
done

for sub in $(make ${make_args} -VPLIST_SUB); do
	case ${sub} in *@comment*)
		options_subs="${options_subs} ${sub%%=*}"
	esac
done

make_args="$(echo ${make_args} | sed 's/WITHOUT/WITH/g')"

awk -v prefix="${PREFIX}/" -v plist_subs="$(make ${make_args} -V PLIST_SUB)" \
	-v options_subs="${options_subs}" '
BEGIN { 
	n_cmds=1;
	separator="###";

	n = split(options_subs, s_array, " ");
	for (i=1; i<=n; i++)
		opt_subs[s_array[i]] = s_array[i];

	n = split(plist_subs, array, " ");
	for (pair=1; pair<=n; pair++) {
		if (split(array[pair], p_array, "=") != 2)
			continue;

		if (opt_subs[p_array[1]] != "")
			continue;

		gsub("\"", "", p_array[2]);
		if (p_array[2] != "" && p_array[2] != "@comment")
			subs[p_array[1]] = p_array[2];
	}
}

function str_replace(string, pattern, new_pattern) {
	new_str=""
	n = split(string, array, pattern);
	if (n > 1) {
		for (i=1; i <= n; i++) {
			if (i != n)
				new_str = new_str array[i] new_pattern;
			else
				new_str = new_str array[i];
		}
	} else
		return string;

	return new_str;
}

function plist_split(string, array) {
	n = index(string, " ");
	array[1] = substr(string,1, n-1);
	array[2] = substr(string, n+1);
}

function keyword_line_tokenize(line, keyword, out) {
	path = chunks = "";

	n = split(line, array, "%%");

	if (n == 1) {
		plist_split(array[1], p);
		out[p[2]] = p[2] separator p[1];
		return;
	}
	for (i=1; i <= n; i++) {
		if (match(array[i], "^@" keyword)) {
			plist_split(array[i], p);
			path = p[2];
			chunks = chunks separator p[1];
			continue;
		}
		if (opt_subs[array[i]] != "") {
			chunks = chunks separator array[i];
			continue;
		}
		if (subs[array[i]] != "") {
			path = path subs[array[i]];
			chunks = chunks separator array[i];
		} else
			path = path array[i];
	}
	out[path] = path chunks;
}

function keyword_line_untokenize(line, keyword) {
	cmd=""

	n = split(line, p, separator);
	path = p[1];

	if (n == 2) {
		printf("%s %s\n", p[2], path);
		return;
	}
	for (i=2; i <= n; i++) {
		if (match(p[i], "^@" keyword)) {
			cmd = cmd p[i];
			continue;
		}
		if (cmd == "")
			cmd = "%%" p[i] "%%";
		else if (subs[p[i]] != "")
			path = str_replace(path, subs[p[i]], "%%" p[i] "%%");
	}
	printf("%s %s\n", cmd, path);
}

/^(%%[0-9A-Z_]*%%)*([a-z]|\/)+/ { # files
	path = chunks = "";

	n = split($0, array, "%%");

	if (n == 1) {
		files[array[1]] = array[1];
		next;
	}
	for (i=1; i <= n; i++) {
		if (opt_subs[array[i]] != "") {
			chunks = chunks separator array[i];
			continue;
		}
		if (subs[array[i]] != "") {
			path = path subs[array[i]];
			chunks = chunks separator array[i];
		} else
			path = path array[i];
	}
	files[path] = path chunks;
}

/^(%%[0-9A-Z_]*%%)*@dir/ { # dirs
	keyword_line_tokenize($0, "dir", dirs);
}

/^(%%[0-9A-Z_]*%%)*@sample/ {
	keyword_line_tokenize($0, "sample", files);
}

/^(%%[0-9A-Z_]*%%)*@/ { # other commands, @exec, @unexec etc
	if (match($0, "@(dir|sample)"))
		next;	
	cmds[n_cmds++] = $0;
}

END {
	"mktemp" | getline tmpfile;
	close("mktemp");
	for (i in files) print files[i] | ("sort -u >" tmpfile);
	close("sort -u >" tmpfile);
	
	while((getline line < tmpfile) > 0) {
		if (match(line, "@sample")) {
			keyword_line_untokenize(line, "sample");
			continue;
		}

		n = split(line, p, separator); 
		path = p[1];

		if (n == 1) {
			print path;
			continue;
		}
		for (i=2; i<=n; i++) {
			if (opt_subs[p[i]] != "") {
				path = "%%" p[i] "%%" path;
				continue;
			}
			if (subs[p[i]] != "") {
				path = str_replace(path, subs[p[i]], "%%" p[i] "%%");
				continue;
			}
			path = p[i] path;
		}
		print path;
	}
	close(tmpfile);
	system("cat /dev/null>" tmpfile);

	for (i in dirs) print dirs[i] | ("sort -u -r >" tmpfile);
	close("sort -u -r >" tmpfile);
	
	while((getline line < tmpfile) > 0)
		keyword_line_untokenize(line, "dir");

	close(tmpfile);
	system("rm " tmpfile);
	
	if (n_cmds > 1) {
		printf("\n@comment Lines below should be sorted manually\n");
		for (i in cmds) print cmds[i];
	}
}' ${plist_file}

#!/bin/sh

readonly PKGNAME="$(make -V PKGNAME 2>/dev/null)"
readonly PREFIX="$(make -V PREFIX 2>/dev/null)"
plist_file="${1}"

if [ -z "${PKGNAME}" -o -z "${PREFIX}" ]; then
	echo "===> This is not port directory"
	exit 1
fi

[ -n "${plist_file}" ] || plist_file=$(make -V PLIST)

if [ ! -f "${plist_file}" ]; then
	echo "===> Plist file was not found: ${plist_file}"
	exit 1
fi

make_args="OPTIONSFILE=/dev/null OPTIONS_FILE=/dev/null"
for opt in $(make -V ALL_OPTIONS); do
	make_args="${make_args} WITH_${opt}=true"
done

awk -v prefix="${PREFIX}/" -v plist_subs="$(make ${make_args} -V PLIST_SUB)" '
BEGIN { 
	n_cmds=1;
	separator="###";

	n = split(plist_subs, s_array, " ");
	if (n > 0) {
		for(pair=1; pair<=n; pair++) {
			if (split(s_array[pair], p_array, "=") != 2)
				continue;
		
			gsub("\"", "", p_array[2]);
			if (p_array[2] == "" || p_array[2] == "@comment")
				subs[p_array[1]] = "null"
			else
				subs[p_array[1]] = p_array[2];
		}
	}
}

function str_replace(string, pattern, new_pattern) {
	new_str=""
	n = split(string, array, pattern);
	if (n > 1) {
		for (i=1; i <= n; i++) {
			if (i != n)
				new_str = new_str array[i] new_pattern;
			else
				new_str = new_str array[i];
		}
	} else
		return string;

	return new_str;
}

function update_plist_subs (string) {
	if (string == "") {
		subs[string] = "null";
		return;
	}
	if (match(string, "^PYTHON_"))
		make_args = " USE_PYTHON=yes";
	if (subs[string] == "") {
		"make -V " string make_args | getline s;
		if (s != "")
			subs[string] = str_replace(s, prefix, "");
		else
			subs[string] = "null";
		close("make -V " string make_args);
	}
	make_args = "";
}

function plist_split(string, array) {
	n = index(string, " ");
	array[1] = substr(string,1, n-1);
	array[2] = substr(string, n+1);
}

function keyword_line_tokenize(line, keyword, out) {
	path = chunks = "";

	n = split(line, array, "%%");

	if (n == 1) {
		plist_split(array[1], p);
		out[p[2]] = p[2] separator p[1];
		return;
	}
	for (i=1; i <= n; i++) {
		if (match(array[i], "^@" keyword)) {
			plist_split(array[i], p);
			path = p[2];
			chunks = chunks separator p[1];
			continue;
		}
		if ((i%2) == 0) {
			update_plist_subs(array[i]);
			if (subs[array[i]] != "null")
				path = path subs[array[i]];
			if (array[i] != "")
				chunks = chunks separator array[i];
		} else
			path = path array[i];
	}
	out[path] = path chunks;
}

function keyword_line_untokenize(line, keyword) {
	cmd=""

	n = split(line, p, separator);
	path = p[1];

	if (n == 2) {
		printf("%s %s\n", p[2], path);
		return;
	}
	for (i=2; i <= n; i++) {
		if (match(p[i], "^@" keyword)) {
			cmd = cmd p[i];
			continue;
		}
		if (cmd == "")
			cmd = "%%" p[i] "%%";
		else if (subs[p[i]] != "null")
			path = str_replace(path, subs[p[i]], "%%" p[i] "%%");
	}
	printf("%s %s\n", cmd, path);
}

/^(%%[0-9A-Z_]*%%)*([a-z]|\/)+/ { # files
	path = chunks = "";

	n = split($0, array, "%%");

	if (n == 1) {
		files[array[1]] = array[1];
		next;
	}
	for (i=1; i <= n; i++) {
		if ((i%2) == 0) {
			update_plist_subs(array[i]);
			if (subs[array[i]] != "null")
				path = path subs[array[i]];
			if (array[i] != "")
				chunks = chunks separator array[i];
		} else
			path = path array[i];
	}
	files[path] = path chunks;
}

/^(%%[0-9A-Z_]*%%)*@dir/ { # dirs
	keyword_line_tokenize($0, "dir", dirs);
}

/^(%%[0-9A-Z_]*%%)*@sample/ {
	keyword_line_tokenize($0, "sample", files);
}

/^(%%[0-9A-Z_]*%%)*@/ { # other commands, @exec, @unexec etc
	if (match($0, "@(dir|sample)"))
		next;	
	cmds[n_cmds++] = $0;
}

END {
	"mktemp" | getline tmpfile;
	close("mktemp");
	
	for (i in cmds)
		if (match(cmds[i], "^@comment \\$FreeBSD")) {
			print cmds[i];
			delete cmds[i];
			o--;
			break;
		}

	for (i in files) print files[i] | ("sort -u >" tmpfile);
	close("sort -u >" tmpfile);
	
	while((getline line < tmpfile) > 0) {
		if (match(line, "@sample")) {
			keyword_line_untokenize(line, "sample");
			continue;
		}

		n = split(line, p, separator); 
		path = p[1];

		if (n == 1) {
			print path;
			continue;
		}
		for (i=2; i<=n; i++) {
			if (subs[p[i]] != "null")
				path = str_replace(path, subs[p[i]], "%%" p[i] "%%");
			else if (i == 2)
				path = "%%" p[i] "%%" path;
		}
		print path;
	}
	close(tmpfile);
	system("cat /dev/null>" tmpfile);

	for (i in dirs) print dirs[i] | ("sort -u -r >" tmpfile);
	close("sort -u -r >" tmpfile);
	
	while((getline line < tmpfile) > 0)
		keyword_line_untokenize(line, "dir");

	close(tmpfile);
	system("rm " tmpfile);
	
	if (n_cmds > 1) {
		printf("\n@comment Lines below should be sorted manually\n");
		for (i in cmds) print cmds[i];
	}
	
#	for (i in subs) printf("%s\t  = %s\n", i, subs[i]);
}' ${plist_file}

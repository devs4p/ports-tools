#!/bin/sh

LANG=C

readonly PAGER="${PAGER:-less}"
readonly PAGER_DIFF="${PAGER_DIFF:-$PAGER}"
readonly PSVN="${PSVN:-svn}"

clean_only=0
dir_cache=""
dir_cache_ignore=""
ignore_empty=0
non_interactive=0
removed_dirs=""

ask_yesno() {
	[ ${non_interactive} -eq 0 ] || return 0

	while true; do
		echo -n "${1} (y/n)? [y] "
		
		read answer
		[ -n "${answer}" ] || answer="y"

		case ${answer} in
		[Nn])
			return 1 ;;
		[Yy])
			return 0
		esac
	done
}

cache_concat() {
	local str="$(eval echo $"$1")"
	[ -z "${str}" ] && str="${2}" || str="${str} ${2}"
	setvar ${1} "${str}"
}

dir_cache_add() {
	local dir="${1}"

	case ${dir_cache} in
	*${dir}*)
		;;
	*)
		cache_concat dir_cache "${dir}"
	esac
}

display_usage() {
	<< EOF >&2 cat
Usage: pcommit [-c|-e|-h|-n]

    -c - clean temp files only
    -e - ignore empty files
    -h - show this help
    -n - non-interactive mode

EOF
	exit 1
}

file_add() {
	local file="${1}"
	case ${file} in *svn-commit*) return 1 ;; esac
	[ ${ignore_empty} -eq 1 -a ! -s "${file}" ] && return 1
	
	if ask_yesno "Add file ${file}"; then
		[ ${non_interactive} -eq 0 ] || echo "===> Adding file ${file}"
		${PSVN} -q add "${file}"
		if [ ${?} -ne 0 ]; then
			echo "===> File addition failed" >&2
			pcommit_exit 1
		fi

		if [ -d "${file}" ]; then
			for child in $(ls "${file}"); do
				file_set_props "${file}/${child}"
			done
		fi
		return 0
	else
		return 1
	fi
}

file_remove() {
	local file="${1}" 
	local n_kind="$(${PSVN} info "${1}"|awk '/^Node Kind/ { print $3 }')"

	if [ "${n_kind}" = "file" ]; then
		for dir in ${removed_dirs}; do
			case $file in $dir/*)
				return 0
			esac
		done
	fi

	if ask_yesno "Remove ${n_kind} ${file}"; then 
		[ ${non_interactive} -eq 0 ] || echo "===> Removing ${n_kind} ${file}"
		${PSVN} -q --force rm "${file}"
		if [ ${?} -ne 0 ]; then
			echo "===> File removal failed" >&2
			pcommit_exit 1
		fi
		
		if [ "${n_kind}" = "file" ]; then 
			case ${file} in *files/*|*scripts/*)
				dir_cache_add "$(dirname "${file}")"
			esac
		else
			cache_concat removed_dirs "${file}"
		fi
		return 0
	else
		[ "${n_kind}" = "file" ] && \
			cache_concat dir_cache_ignore "$(dirname "${file}")"
		return 1
	fi
}

file_set_props() {
	local file="${1}"
	[ -d "${file}" -o ! -e "${file}" ] && return 1
	
	case $(egrep -- '\$FreeBSD\$|\$[BDFSer]+:' "${file}" >/dev/null || echo ${?}) in
	"")	# matched pattern
		${PSVN} -q -- propset svn:keywords "FreeBSD=%H" "${file}"
		${PSVN} -q -- propdel fbsd:nokeywords "${file}" ;;
	1)	# no match
		${PSVN} -q -- propset fbsd:nokeywords yes "${file}"
		${PSVN} -q -- propdel svn:keywords "${file}" ;;
	esac

	[ "${_file##/*}" != "bsd.port.mk" ] && \
		${PSVN} -q -- propset svn:eol-style native "${file}"
	${PSVN} -q -- propset svn:mime-type text/plain "${file}"
	${PSVN} -q -- propdel cvs2svn:cvs-rev "${file}"
}

pcommit_exit() {
	[ -z "${tempfile}" ] || rm -f ${tempfile}
	exit ${1}
}

remove_empty_dirs() {
	for dir in ${dir_cache}; do
		[ -d ${dir} ] || continue
		case ${dir_cache_ignore} in *${dir}*) continue ;; esac
		
		if [ -z "$(ls ${dir} 2>&1)" ]; then
			echo "===> Removing empty directory ${dir}"
			${PSVN} -q rm ${dir}
		fi
	done
}

while getopts "cehn" option; do
	case ${option} in
	c)
		clean_only=1 ;;
	e)
		ignore_empty=1 ;;
	n)
		non_interactive=1 ;;
	*)
		display_usage
	esac
done

if [ -n "$(make -V PORTNAME)" ]; then
	depth=2
else 
	[ -n "$(make -V PORTSTOP)" ] && depth=4 || depth=3
fi

wrk_dirs="$(find . -name work -type d -depth $((depth-1)) | sed 's|^./||g')"
if [ -n "${wrk_dirs}" ]; then
	for wdir in ${wrk_dirs}; do
		if [ ${depth} -ne 2 ]; then
			echo "===> Running 'make clean' in ${wdir%%/work}"
			make_args="-C ${wdir%%/work}"
		else
			echo "===> Running 'make clean'"
			make_args=""
		fi

		ret="$(make ${make_args} clean 2>/dev/null)"
		if [ -n "$(echo ${ret} | grep 'not writable')" ]; then
			if [ ${depth} -ne 2 ]; then
				echo "===> Failed to 'make clean' in ${wdir%%/work}" >&2
			else
				echo "===> Failed to 'make clean'" >&2
			fi
			exit 1
		fi
	done
fi

rej_files="$(find . -name "*.rej" -maxdepth ${depth} | sed 's|^./||g')"
if [ -n "${rej_files}" ]; then
	echo "===> Found rejected patch files" >&2
	echo ${rej_files} | tr ' ' '\n'
	exit 1
fi

old_files="$(find -E . \( -name "*.orig" -or -name "svn-commit.*" \) \
	! -regex '.*(\.svn|work)/.*' -delete -print -maxdepth ${depth} | \
	sed 's|^./||g')"
if [ -n "${old_files}" ]; then
	echo "===> Removed old temporary files"
	echo ${old_files} | tr ' ' '\n'
fi
[ ${clean_only} -eq 0 ] || exit

if [ ${ignore_empty} -eq 0 ]; then
	empty_files="$(find . -maxdepth ${depth} -type f -size 0 \
			! -regex '.*\.svn/.*' | sed 's|^./||')"
	for file in ${empty_files}; do
		${PSVN} info "${file}" >/dev/null 2>&1
		if [ ${?} -eq 0 ]; then
			file_remove "${file}"
		else
			rm -f "${file}" && \
				echo "===> Removed empty untracked file ${file}"
		fi
	done
fi

tempfile="$(mktemp -t pcommit)"
if [ -z "${tempfile}" ]; then
	echo "===> Failed to create temporary file" >&2
	exit 1
fi
trap 'pcommit_exit 1' int

${PSVN} --show-updates status > ${tempfile}
if [ ${?} -ne 0 ]; then
	echo "===> '${PSVN} status' failed" >&2
	pcommit_exit 1 
fi

old_IFS=${IFS}
IFS=$'\n'

for line in $(cat ${tempfile}); do
	change="$(echo "${line}" | awk '{
		if (match($0, "^Status"))
			next;
			
		mod = substr($0,1,1);
		if (mod == "?")
			mod="N";
		
		upg = substr($0,9,1);
		if (mod == "M" && upg == "*")
			mod="U";
		
		print mod;
	}')"
	[ "${change}" = " " -o -z "${change}" ] && continue
	file="$(echo "${line}" | awk '{ print $NF }')"
	tracked=0

	case ${change} in
	!)
		file_remove "${file}"
		[ ${?} -eq 1 ] || tracked=1 ;;
	N)
		file_add "${file}"
		tracked=${?} ;;
	U)
		echo "===> Updating ${file}"
		${PSVN} -q update "${file}"
	esac

	[ ${tracked} -eq 1 ] || file_set_props "${file}"
done

rm ${tempfile}
IFS=${old_IFS}

remove_empty_dirs

if [ ${non_interactive} -eq 1 ]; then
	${PSVN} commit
	exit ${?}
fi

while true; do
	printf "\n[c]ommit [v]iew diff [s]vn status [q]uit"
	echo -n "> "

	read cmd
	case ${cmd} in
	[Cc])
		${PSVN} commit
		exit ${?} ;;
	[Qq])
		exit ;;
	[Ss])
		${PSVN} status ;;
	[Vv])
		${PSVN} diff | ${PAGER_DIFF} ;;
	*)
		echo "No such command: ${cmd}"
	esac
done
